<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>RepVault</title>

  <!-- PWA Meta -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0a0a0f">
  <meta name="background-color" content="#0a0a0f">

  <!-- iOS PWA Meta -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="RepVault">
  <link rel="apple-touch-icon" href="icon-192.png">

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Outfit:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
    body {
      background: #0a0a0f; color: #e8e8f0; font-family: 'Outfit', sans-serif;
      overflow-x: hidden; -webkit-font-smoothing: antialiased;
      padding-top: env(safe-area-inset-top);
    }
    input, select, textarea { font-family: 'JetBrains Mono', monospace; }
    ::-webkit-scrollbar { width: 4px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #2a2a3a; border-radius: 2px; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes slideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes countPulse { 0% { transform: scale(1); } 50% { transform: scale(1.08); } 100% { transform: scale(1); } }
    .fade-in { animation: fadeIn 0.3s ease-out; }
    .slide-up { animation: slideUp 0.4s ease-out; }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- React via CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>

  <script>
    // ============================================================
    // REPVAULT - Production PWA Build
    // ============================================================
    const { useState, useEffect, useRef, useCallback, useMemo, createContext, useContext, createElement: h, Fragment } = React;

    const STORAGE_KEY = "repvault_v2_master";
    const PHASES = { PREP: "PREP", WORK: "WORK", REST_SET: "REST_SET", REST_EX: "REST_EX", DONE: "DONE" };
    const DEFAULT_TIMERS = { prep: 10, work: 45, restSet: 60, restEx: 60 };
    const SETS_PER_EXERCISE = 4;
    const DAYS = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];

    // Muscle groups ‚Äî order matters: more specific phrases checked first
    const MUSCLE_GROUPS = ["chest", "back", "shoulders", "glutes", "quads", "hamstrings", "calves", "biceps", "triceps", "core", "cardio"];
    const MUSCLE_RULES = [
      // Multi-word phrases first (most specific wins)
      { phrase: "chest supported row", group: "back" },
      { phrase: "chest-supported row", group: "back" },
      { phrase: "t-bar row", group: "back" },
      { phrase: "t bar row", group: "back" },
      { phrase: "cable row", group: "back" },
      { phrase: "barbell row", group: "back" },
      { phrase: "dumbbell row", group: "back" },
      { phrase: "pendlay row", group: "back" },
      { phrase: "seated row", group: "back" },
      { phrase: "bent over row", group: "back" },
      { phrase: "upright row", group: "shoulders" },
      { phrase: "face pull", group: "back" },
      { phrase: "rear delt", group: "back" },
      { phrase: "back ext", group: "back" },
      { phrase: "lat pulldown", group: "back" },
      { phrase: "wide-grip lat", group: "back" },
      { phrase: "close-grip lat", group: "back" },
      { phrase: "pull up", group: "back" },
      { phrase: "pullup", group: "back" },
      { phrase: "chin up", group: "back" },
      { phrase: "chinup", group: "back" },
      { phrase: "pulldown", group: "back" },
      { phrase: "shoulder press", group: "shoulders" },
      { phrase: "overhead press", group: "shoulders" },
      { phrase: "ohp", group: "shoulders" },
      { phrase: "military press", group: "shoulders" },
      { phrase: "arnold press", group: "shoulders" },
      { phrase: "lateral raise", group: "shoulders" },
      { phrase: "front raise", group: "shoulders" },
      { phrase: "delt", group: "shoulders" },
      { phrase: "shoulder", group: "shoulders" },
      { phrase: "bench press", group: "chest" },
      { phrase: "chest fly", group: "chest" },
      { phrase: "chest press", group: "chest" },
      { phrase: "cable fly", group: "chest" },
      { phrase: "crossover", group: "chest" },
      { phrase: "pec deck", group: "chest" },
      { phrase: "pec", group: "chest" },
      { phrase: "push up", group: "chest" },
      { phrase: "pushup", group: "chest" },
      { phrase: "incline dumbbell", group: "chest" },
      { phrase: "decline dumbbell", group: "chest" },
      { phrase: "fly", group: "chest" },
      { phrase: "flye", group: "chest" },
      { phrase: "bench", group: "chest" },
      { phrase: "hip thrust", group: "glutes" },
      { phrase: "glute bridge", group: "glutes" },
      { phrase: "glute", group: "glutes" },
      { phrase: "kickback", group: "glutes" },
      { phrase: "leg curl", group: "hamstrings" },
      { phrase: "hamstring", group: "hamstrings" },
      { phrase: "rdl", group: "hamstrings" },
      { phrase: "romanian deadlift", group: "hamstrings" },
      { phrase: "stiff leg", group: "hamstrings" },
      { phrase: "good morning", group: "hamstrings" },
      { phrase: "nordic", group: "hamstrings" },
      { phrase: "leg ext", group: "quads" },
      { phrase: "leg extension", group: "quads" },
      { phrase: "leg press", group: "quads" },
      { phrase: "squat", group: "quads" },
      { phrase: "split squat", group: "quads" },
      { phrase: "lunge", group: "quads" },
      { phrase: "step up", group: "quads" },
      { phrase: "goblet", group: "quads" },
      { phrase: "hack squat", group: "quads" },
      { phrase: "quad", group: "quads" },
      { phrase: "calf raise", group: "calves" },
      { phrase: "calf", group: "calves" },
      { phrase: "bicep curl", group: "biceps" },
      { phrase: "bicep", group: "biceps" },
      { phrase: "hammer curl", group: "biceps" },
      { phrase: "preacher", group: "biceps" },
      { phrase: "concentration curl", group: "biceps" },
      { phrase: "curl", group: "biceps" },
      { phrase: "tricep", group: "triceps" },
      { phrase: "pushdown", group: "triceps" },
      { phrase: "skull crush", group: "triceps" },
      { phrase: "close grip", group: "triceps" },
      { phrase: "extension", group: "triceps" },
      { phrase: "dip", group: "chest" },
      { phrase: "deadlift", group: "back" },
      { phrase: "shrug", group: "back" },
      { phrase: "row", group: "back" },
      { phrase: "pull", group: "back" },
      { phrase: "lat", group: "back" },
      { phrase: "press", group: "chest" },
      { phrase: "crunch", group: "core" },
      { phrase: "plank", group: "core" },
      { phrase: "sit up", group: "core" },
      { phrase: "situp", group: "core" },
      { phrase: "oblique", group: "core" },
      { phrase: "russian twist", group: "core" },
      { phrase: "leg raise", group: "core" },
      { phrase: "hollow", group: "core" },
      { phrase: "woodchop", group: "core" },
      { phrase: "pallof", group: "core" },
      { phrase: "ab ", group: "core" },
      { phrase: "core", group: "core" },
    ];
    const CARDIO_LIST = ["run", "bike", "swim", "cycle", "jog", "sprint", "elliptical", "stair", "walk", "treadmill", "rowing machine", "hiit"];

    function detectMuscle(name) {
      const l = name.toLowerCase();
      for (const rule of MUSCLE_RULES) { if (l.includes(rule.phrase)) return rule.group; }
      if (CARDIO_LIST.some(k => l.includes(k))) return "cardio";
      return "other";
    }
    function isCardio(name) { const l = name.toLowerCase(); return CARDIO_LIST.some(k => l.includes(k)); }
    function deepClone(o) { try { return JSON.parse(JSON.stringify(o, (_, v) => typeof v === "number" && isNaN(v) ? null : v)); } catch { return {}; } }
    function genId() { return Date.now().toString(36) + Math.random().toString(36).slice(2, 8); }
    function fmtTime(s) { if (s < 0) s = 0; return `${Math.floor(s / 60)}:${Math.floor(s % 60).toString().padStart(2, "0")}`; }
    function fmtDur(s) { const hr = Math.floor(s / 3600), m = Math.floor((s % 3600) / 60), sec = Math.floor(s % 60); return hr > 0 ? `${hr}h ${m}m` : m > 0 ? `${m}m ${sec}s` : `${sec}s`; }

    const C = {
      bg: "#0a0a0f", surface: "#12121a", surfaceLight: "#1a1a28", border: "#2a2a3a",
      text: "#e8e8f0", textDim: "#8888a0",
      cyan: "#00e5ff", cyanDim: "#00e5ff40", green: "#39ff14", greenDim: "#39ff1440",
      amber: "#ffb300", amberDim: "#ffb30040", red: "#ff3d3d", redDim: "#ff3d3d40", purple: "#b388ff",
    };
    const phaseColor = { [PHASES.PREP]: C.amber, [PHASES.WORK]: C.cyan, [PHASES.REST_SET]: C.green, [PHASES.REST_EX]: C.purple, [PHASES.DONE]: C.green };

    // --- Storage ---
    function loadDB() {
      try { const d = localStorage.getItem(STORAGE_KEY); if (d) return JSON.parse(d); } catch {}
      // Legacy scan
      try {
        const keys = ["ironfocus_data", "ironfocus_history", "ironfocus_blueprints", "ironfocus_v2_master"];
        let merged = emptyDB();
        for (const k of keys) {
          try { const r = localStorage.getItem(k); if (r) { const d = JSON.parse(r); if (d.history) merged.history.push(...d.history); if (d.blueprints) Object.assign(merged.blueprints, d.blueprints); if (d.pbs) Object.assign(merged.pbs, d.pbs); } } catch {}
        }
        if (merged.history.length > 0 || Object.keys(merged.blueprints).length > 0) return merged;
      } catch {}
      return emptyDB();
    }
    function saveDB(db) { try { localStorage.setItem(STORAGE_KEY, JSON.stringify(deepClone(db))); } catch (e) { console.error("Save failed:", e); } }
    function emptyDB() { return { history: [], blueprints: {}, pbs: {}, settings: { timers: { ...DEFAULT_TIMERS }, audioEnabled: true } }; }

    // --- Audio Engine ---
    class AudioEngine {
      constructor() { this.ctx = null; this.enabled = true; this.hb = null; }
      init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); if (this.ctx.state === "suspended") this.ctx.resume(); }
      pip(f = 880, d = 0.08) { if (!this.enabled || !this.ctx) return; const o = this.ctx.createOscillator(), g = this.ctx.createGain(); o.connect(g); g.connect(this.ctx.destination); o.frequency.value = f; o.type = "sine"; g.gain.setValueAtTime(0.3, this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + d); o.start(this.ctx.currentTime); o.stop(this.ctx.currentTime + d); }
      countdownPip() { this.pip(1200, 0.06); }
      phasePip() { this.pip(660, 0.15); }
      speak(t) { if (!this.enabled || !window.speechSynthesis) return; window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(t); u.rate = 1.1; u.pitch = 0.9; u.volume = 0.8; window.speechSynthesis.speak(u); }
      startHeartbeat() { if (this.hb) return; this.init(); this.hb = setInterval(() => { if (!this.ctx) return; const o = this.ctx.createOscillator(), g = this.ctx.createGain(); o.connect(g); g.connect(this.ctx.destination); g.gain.setValueAtTime(0.001, this.ctx.currentTime); o.start(this.ctx.currentTime); o.stop(this.ctx.currentTime + 0.01); }, 10000); }
      stopHeartbeat() { if (this.hb) { clearInterval(this.hb); this.hb = null; } }
      toggle() { this.enabled = !this.enabled; return this.enabled; }
    }
    const audio = new AudioEngine();

    function updateMedia(title, artist) { if ("mediaSession" in navigator) { try { navigator.mediaSession.metadata = new MediaMetadata({ title, artist, album: "RepVault" }); } catch {} } }

    const AppCtx = createContext(null);

    // ============================================================
    // MAIN APP
    // ============================================================
    function App() {
      const [db, setDb] = useState(() => loadDB());
      const [screen, setScreen] = useState("home");
      const [wo, setWo] = useState(null);
      const [notif, setNotif] = useState(null);
      // Global timer state ‚Äî persists across screen navigation
      const [phase, setPhase] = useState(PHASES.PREP);
      const [timer, setTimer] = useState(DEFAULT_TIMERS.prep);
      const [paused, setPaused] = useState(false);
      const [clock, setClock] = useState(0);

      const persist = useCallback((updater) => {
        setDb(prev => { const next = typeof updater === "function" ? updater(prev) : updater; saveDB(next); return next; });
      }, []);
      const notify = useCallback((msg, type = "info") => { setNotif({ msg, type, id: Date.now() }); setTimeout(() => setNotif(null), 2500); }, []);

      const ctx = { db, persist, notify, screen, setScreen, wo, setWo, phase, setPhase, timer, setTimer, paused, setPaused, clock, setClock };

      return h(AppCtx.Provider, { value: ctx },
        notif && h(Toast, notif),
        screen === "home" && h(Home),
        screen === "train" && h(Train),
        screen === "blueprints" && h(Blueprints),
        screen === "history" && h(History),
        screen === "analytics" && h(Analytics),
        screen === "settings" && h(Settings),
        screen === "export" && h(Export),
        h(NavBar),
      );
    }

    // --- Toast ---
    function Toast({ msg, type }) {
      const colors = { info: C.cyan, success: C.green, error: C.red, warn: C.amber };
      return h("div", { className: "slide-up", style: {
        position: "fixed", top: 16, left: "50%", transform: "translateX(-50%)", background: C.surface,
        border: `1px solid ${colors[type] || C.cyan}`, color: colors[type] || C.cyan,
        padding: "10px 20px", borderRadius: 12, fontSize: 13, fontWeight: 500, zIndex: 9999,
        maxWidth: "90%", textAlign: "center", boxShadow: `0 4px 20px ${(colors[type] || C.cyan)}30`,
      }}, msg);
    }

    // --- NavBar ---
    function NavBar() {
      const { screen, setScreen, wo } = useContext(AppCtx);
      const items = [
        { id: "home", icon: "‚ö°", label: "Home" }, { id: "blueprints", icon: "üìã", label: "Plans" },
        { id: "history", icon: "üìä", label: "History" }, { id: "analytics", icon: "üìà", label: "Stats" },
        { id: "settings", icon: "‚öôÔ∏è", label: "Settings" },
      ];
      // Insert training tab when workout is active
      if (wo) items.splice(0, 0, { id: "train", icon: "üî•", label: "Workout", active: true });
      return h("div", { style: {
        position: "fixed", bottom: 0, left: "50%", transform: "translateX(-50%)", width: "100%", maxWidth: 500,
        background: `${C.surface}f0`, borderTop: `1px solid ${C.border}`, display: "flex",
        padding: "6px 0 env(safe-area-inset-bottom, 8px)", backdropFilter: "blur(20px)", zIndex: 100,
      }}, items.map(it => h("button", { key: it.id, onClick: () => setScreen(it.id), style: {
        flex: 1, background: "none", border: "none", color: screen === it.id ? (it.active ? C.green : C.cyan) : (it.active ? C.amber : C.textDim),
        display: "flex", flexDirection: "column", alignItems: "center", gap: 2, padding: "6px 0", cursor: "pointer",
        position: "relative",
      }}, h("span", { style: { fontSize: 18 } }, it.icon), h("span", { style: { fontSize: 10, fontWeight: screen === it.id ? 600 : 400 } }, it.label),
        it.active && screen !== "train" && h("div", { style: { position: "absolute", top: 2, right: "15%", width: 7, height: 7, borderRadius: "50%", background: C.green, boxShadow: `0 0 6px ${C.green}` } }),
      )));
    }

    // ============================================================
    // HOME
    // ============================================================
    function Home() {
      const { db, setScreen, setWo, notify } = useContext(AppCtx);
      const [quickText, setQuickText] = useState("");
      const [showQuick, setShowQuick] = useState(false);

      const todayIdx = new Date().getDay();
      const todayName = DAYS[todayIdx === 0 ? 6 : todayIdx - 1];
      const todayBP = db.blueprints?.[todayName];

      const weekHistory = db.history.filter(x => (Date.now() - new Date(x.date).getTime()) / 864e5 <= 7);
      const totalVol = weekHistory.reduce((s, x) => s + (x.exercises || []).reduce((es, ex) => es + (ex.sets || []).reduce((ss, st) => ss + (st.weight || 0) * (st.reps || 0), 0), 0), 0);

      // Weekly sets per muscle group
      const weekMuscleSets = useMemo(() => {
        const counts = {};
        weekHistory.forEach(session => {
          (session.exercises || []).forEach(ex => {
            const muscle = ex.muscle || detectMuscle(ex.name);
            if (muscle && muscle !== "other" && muscle !== "cardio") {
              counts[muscle] = (counts[muscle] || 0) + (ex.sets || []).length;
            }
          });
        });
        return Object.entries(counts).sort((a, b) => b[1] - a[1]);
      }, [weekHistory]);

      function makeExercises(names) {
        return names.map(name => ({
          id: genId(), name, muscle: detectMuscle(name), isCardio: isCardio(name),
          sets: isCardio(name) ? [{ id: genId(), duration: 0, completed: false }]
            : Array.from({ length: SETS_PER_EXERCISE }, () => ({ id: genId(), weight: 0, reps: 0, completed: false })),
        }));
      }

      function startBP(bp) { setWo({ id: genId(), exercises: makeExercises(bp.exercises.map(e => e.name)), currentExIdx: 0, currentSetIdx: 0, startTime: Date.now() }); setScreen("train"); }
      function startQuick() { if (!quickText.trim()) return; const lines = quickText.split("\n").map(l => l.trim()).filter(Boolean); setWo({ id: genId(), exercises: makeExercises(lines), currentExIdx: 0, currentSetIdx: 0, startTime: Date.now() }); setScreen("train"); notify(`Loaded ${lines.length} exercises`, "success"); }
      function startEmpty() { setWo({ id: genId(), exercises: [], currentExIdx: 0, currentSetIdx: 0, startTime: Date.now() }); setScreen("train"); }

      return h("div", { className: "fade-in", style: { padding: "20px 16px", maxWidth: 500, margin: "0 auto", paddingBottom: 90 } },
        // Header
        h("div", { style: { textAlign: "center", padding: "30px 0 20px" } },
          h("h1", { style: { fontSize: 36, fontWeight: 900, letterSpacing: -1, background: `linear-gradient(135deg, ${C.cyan}, ${C.green})`, WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent" } }, "REPVAULT"),
          h("p", { style: { color: C.textDim, fontSize: 13, marginTop: 4, fontWeight: 300 } }, "Your Training. Locked In."),
        ),
        // Weekly summary
        h("div", { style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}`, marginBottom: 16 } },
          h("div", { style: { fontSize: 11, color: C.textDim, textTransform: "uppercase", letterSpacing: 1, marginBottom: 12 } }, "This Week"),
          h("div", { style: { display: "flex", gap: 16 } },
            h("div", { style: { flex: 1, textAlign: "center" } }, h("div", { style: { fontSize: 28, fontWeight: 700, color: C.cyan, fontFamily: "'JetBrains Mono'" } }, weekHistory.length), h("div", { style: { fontSize: 11, color: C.textDim } }, "Sessions")),
            h("div", { style: { width: 1, background: C.border } }),
            h("div", { style: { flex: 1, textAlign: "center" } }, h("div", { style: { fontSize: 28, fontWeight: 700, color: C.green, fontFamily: "'JetBrains Mono'" } }, totalVol > 1000 ? `${(totalVol / 1000).toFixed(1)}k` : totalVol), h("div", { style: { fontSize: 11, color: C.textDim } }, "Volume (kg)")),
            h("div", { style: { width: 1, background: C.border } }),
            h("div", { style: { flex: 1, textAlign: "center" } }, h("div", { style: { fontSize: 28, fontWeight: 700, color: C.amber, fontFamily: "'JetBrains Mono'" } }, Object.keys(db.pbs || {}).length), h("div", { style: { fontSize: 11, color: C.textDim } }, "PBs")),
          ),
        ),
        // Weekly muscle group breakdown
        weekMuscleSets.length > 0 && h("div", { style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}`, marginBottom: 16 } },
          h("div", { style: { fontSize: 11, color: C.textDim, textTransform: "uppercase", letterSpacing: 1, marginBottom: 12 } }, "Weekly Sets by Muscle"),
          h("div", { style: { display: "flex", flexWrap: "wrap", gap: 6 } },
            weekMuscleSets.map(([muscle, count]) => {
              const maxSets = weekMuscleSets[0]?.[1] || 1;
              const intensity = Math.max(0.3, count / maxSets);
              const muscleColors = { chest: C.cyan, back: C.green, shoulders: C.amber, legs: C.purple, biceps: C.cyan, triceps: C.green, core: C.amber };
              const mc = muscleColors[muscle] || C.cyan;
              return h("div", { key: muscle, style: { display: "flex", alignItems: "center", gap: 8, padding: "8px 12px", background: `${mc}${Math.round(intensity * 20).toString(16).padStart(2, "0")}`, border: `1px solid ${mc}30`, borderRadius: 10, minWidth: "calc(50% - 3px)" } },
                h("div", { style: { flex: 1 } },
                  h("div", { style: { fontSize: 12, fontWeight: 600, color: C.text, textTransform: "capitalize" } }, muscle),
                ),
                h("div", { style: { fontSize: 20, fontWeight: 700, color: mc, fontFamily: "'JetBrains Mono'" } }, count),
              );
            }),
          ),
        ),
        // Today's blueprint
        todayBP && h("button", { onClick: () => startBP(todayBP), style: { width: "100%", background: `linear-gradient(135deg, ${C.cyan}15, ${C.green}15)`, border: `1px solid ${C.cyan}40`, borderRadius: 16, padding: 20, color: C.text, cursor: "pointer", textAlign: "left", marginBottom: 16 } },
          h("div", { style: { fontSize: 11, color: C.cyan, textTransform: "uppercase", letterSpacing: 1, marginBottom: 6 } }, `${todayName}'s Plan`),
          h("div", { style: { fontSize: 18, fontWeight: 700, marginBottom: 8 } }, todayBP.name || `${todayName} Session`),
          h("div", { style: { fontSize: 12, color: C.textDim } }, `${todayBP.exercises?.length || 0} exercises ‚Ä¢ Tap to start`),
        ),
        // Quick start buttons
        h("div", { style: { display: "flex", gap: 10, marginBottom: 16 } },
          h("button", { onClick: () => setShowQuick(!showQuick), style: { flex: 1, background: C.surface, border: `1px solid ${C.border}`, borderRadius: 12, padding: "16px 12px", color: C.text, cursor: "pointer", fontSize: 14, fontWeight: 600 } }, "üìù Bulk Import"),
          h("button", { onClick: startEmpty, style: { flex: 1, background: C.surface, border: `1px solid ${C.border}`, borderRadius: 12, padding: "16px 12px", color: C.text, cursor: "pointer", fontSize: 14, fontWeight: 600 } }, "‚ûï Empty Session"),
        ),
        // Bulk import
        showQuick && h("div", { className: "slide-up", style: { background: C.surface, borderRadius: 16, padding: 16, border: `1px solid ${C.border}`, marginBottom: 16 } },
          h("div", { style: { fontSize: 12, color: C.textDim, marginBottom: 8 } }, "One exercise per line:"),
          h("textarea", { value: quickText, onChange: e => setQuickText(e.target.value), placeholder: "Bench Press\nLat Pulldown\nSquat\nBicep Curl", rows: 6, style: { width: "100%", background: C.bg, border: `1px solid ${C.border}`, borderRadius: 8, padding: 12, color: C.text, fontSize: 14, resize: "none", outline: "none" } }),
          h("button", { onClick: startQuick, style: { width: "100%", marginTop: 10, background: C.cyan, color: C.bg, border: "none", borderRadius: 10, padding: 14, fontSize: 15, fontWeight: 700, cursor: "pointer" } }, "Load & Start"),
        ),
        // Export
        h("button", { onClick: () => setScreen("export"), style: { width: "100%", background: C.surface, border: `1px solid ${C.border}`, borderRadius: 12, padding: 14, color: C.textDim, cursor: "pointer", fontSize: 13, fontWeight: 500 } }, "üì§ Export AI-Ready Data"),
      );
    }

    // ============================================================
    // TRAINING SCREEN
    // ============================================================
    function Train() {
      const { db, persist, notify, setScreen, wo, setWo, phase, setPhase, timer, setTimer, paused, setPaused, clock, setClock } = useContext(AppCtx);
      const [showAdd, setShowAdd] = useState(false);
      const [addText, setAddText] = useState("");
      const [showQuit, setShowQuit] = useState(false);

      const timerRef = useRef(null);
      const clockRef = useRef(null);
      const lastTick = useRef(Date.now());
      const backRef = useRef(0);
      const timers = db.settings?.timers || DEFAULT_TIMERS;
      const curEx = wo?.exercises[wo.currentExIdx];
      const totalSets = wo ? wo.exercises.reduce((s, e) => s + e.sets.length, 0) : 0;
      const doneSets = wo ? wo.exercises.reduce((s, e) => s + e.sets.filter(x => x.completed).length, 0) : 0;

      // PB data for current exercise
      const curPB = curEx ? db.pbs?.[curEx.name.toLowerCase()] : null;

      // Last performance ‚Äî find the most recent session with this exercise and extract per-set weights
      const lastPerf = useMemo(() => {
        if (!curEx) return null;
        const nm = curEx.name.toLowerCase();
        for (let i = db.history.length - 1; i >= 0; i--) {
          const ex = db.history[i].exercises?.find(e => e.name.toLowerCase() === nm);
          if (ex) return {
            date: db.history[i].date,
            sets: ex.sets || [],
            vol: (ex.sets || []).reduce((s, st) => s + (st.weight || 0) * (st.reps || 0), 0),
          };
        }
        return null;
      }, [curEx?.name, db.history]);

      // Auto-populate weights from last session when exercise changes
      const prevExIdxRef = useRef(null);
      useEffect(() => {
        if (!wo || !curEx || curEx.isCardio) return;
        if (prevExIdxRef.current === wo.currentExIdx) return;
        prevExIdxRef.current = wo.currentExIdx;
        if (lastPerf && lastPerf.sets.length > 0) {
          // Only auto-fill if sets have no weight yet (fresh exercise)
          const allEmpty = curEx.sets.every(s => !s.weight || s.weight === 0);
          if (allEmpty) {
            setWo(prev => {
              const next = deepClone(prev);
              const ex = next.exercises[next.currentExIdx];
              ex.sets.forEach((s, i) => {
                const historySet = lastPerf.sets[i] || lastPerf.sets[lastPerf.sets.length - 1];
                if (historySet) {
                  s.weight = historySet.weight || 0;
                  s.reps = historySet.reps || 0;
                }
              });
              return next;
            });
          }
        }
      }, [wo?.currentExIdx, lastPerf]);

      function updateSet(ei, si, field, val) {
        setWo(prev => {
          const next = deepClone(prev);
          next.exercises[ei].sets[si][field] = val;
          // Weight continuity: Set 1 weight fills unfilled subsequent sets
          if (field === "weight" && si === 0) {
            for (let i = 1; i < next.exercises[ei].sets.length; i++) {
              if (!next.exercises[ei].sets[i].weight) next.exercises[ei].sets[i].weight = val;
            }
          }
          return next;
        });
      }

      useEffect(() => { audio.init(); audio.startHeartbeat(); return () => audio.stopHeartbeat(); }, []);

      // Timer tick ‚Äî runs globally even when navigated away
      useEffect(() => {
        if (paused || phase === PHASES.DONE || !wo) return;
        lastTick.current = Date.now();
        timerRef.current = setInterval(() => {
          const now = Date.now(), el = (now - lastTick.current) / 1000;
          lastTick.current = now;
          setTimer(prev => {
            const n = prev - el;
            if (n <= 3.1 && n > 2.9) audio.countdownPip();
            if (n <= 2.1 && n > 1.9) audio.countdownPip();
            if (n <= 1.1 && n > 0.9) audio.countdownPip();
            if (n <= 0) { audio.phasePip(); advancePhase(); return 0; }
            return n;
          });
        }, 100);
        return () => clearInterval(timerRef.current);
      }, [phase, paused, wo?.currentExIdx, wo?.currentSetIdx, wo]);

      // Session clock
      useEffect(() => {
        if (!wo) return;
        clockRef.current = setInterval(() => setClock(Math.floor((Date.now() - wo.startTime) / 1000)), 1000);
        return () => clearInterval(clockRef.current);
      }, [wo?.startTime]);

      useEffect(() => { if (curEx && wo) updateMedia(`${curEx.name} - Set ${wo.currentSetIdx + 1}`, `${phase} ‚Ä¢ ${fmtTime(timer)}`); }, [phase, timer, curEx?.name, wo?.currentSetIdx]);

      function advancePhase() {
        if (!wo) return;
        const ex = wo.exercises[wo.currentExIdx];
        if (!ex) { finish(); return; }
        if (phase === PHASES.PREP) { setPhase(PHASES.WORK); setTimer(timers.work); audio.speak(`${ex.name}, Set ${wo.currentSetIdx + 1}, Work`); }
        else if (phase === PHASES.WORK) {
          setWo(prev => { const n = deepClone(prev); if (n.exercises[n.currentExIdx]?.sets[n.currentSetIdx]) n.exercises[n.currentExIdx].sets[n.currentSetIdx].completed = true; return n; });
          const lastSet = wo.currentSetIdx >= ex.sets.length - 1, lastEx = wo.currentExIdx >= wo.exercises.length - 1;
          if (lastSet && lastEx) { setPhase(PHASES.DONE); setTimer(0); audio.speak("Workout Complete"); }
          else if (lastSet) { setPhase(PHASES.REST_EX); setTimer(timers.restEx); audio.speak("Rest between exercises"); }
          else { setPhase(PHASES.REST_SET); setTimer(timers.restSet); audio.speak(`Rest. Next: Set ${wo.currentSetIdx + 2}`); }
        }
        else if (phase === PHASES.REST_SET) { setWo(prev => ({ ...prev, currentSetIdx: prev.currentSetIdx + 1 })); setPhase(PHASES.WORK); setTimer(timers.work); audio.speak(`${ex.name}, Set ${wo.currentSetIdx + 2}, Work`); }
        else if (phase === PHASES.REST_EX) { const ni = wo.currentExIdx + 1; setWo(prev => ({ ...prev, currentExIdx: ni, currentSetIdx: 0 })); setPhase(PHASES.PREP); setTimer(timers.prep); const ne = wo.exercises[ni]; if (ne) audio.speak(`Next: ${ne.name}`); }
      }

      function skip() { clearInterval(timerRef.current); advancePhase(); }

      function goBack() {
        const now = Date.now();
        if (timer > 3 || now - backRef.current > 2000) {
          backRef.current = now;
          if (phase === PHASES.WORK) setTimer(timers.work); else if (phase === PHASES.REST_SET) setTimer(timers.restSet);
          else if (phase === PHASES.REST_EX) setTimer(timers.restEx); else if (phase === PHASES.PREP) setTimer(timers.prep);
        } else {
          if (wo.currentSetIdx > 0) { setWo(prev => ({ ...prev, currentSetIdx: prev.currentSetIdx - 1 })); setPhase(PHASES.WORK); setTimer(timers.work); }
          else if (wo.currentExIdx > 0) { const pi = wo.currentExIdx - 1; setWo(prev => ({ ...prev, currentExIdx: pi, currentSetIdx: prev.exercises[pi].sets.length - 1 })); setPhase(PHASES.WORK); setTimer(timers.work); }
        }
      }

      function finish() {
        const session = { id: wo.id, date: new Date().toISOString(), duration: Math.floor((Date.now() - wo.startTime) / 1000), exercises: wo.exercises.map(e => ({ name: e.name, muscle: e.muscle, isCardio: e.isCardio, sets: e.sets.map(s => ({ weight: s.weight || 0, reps: s.reps || 0, duration: s.duration || 0, completed: s.completed })) })) };
        const newPBs = { ...(db.pbs || {}) };
        session.exercises.forEach(ex => { const k = ex.name.toLowerCase(); const b = newPBs[k] || { maxWeight: 0, maxVolume: 0, maxReps: 0 }; ex.sets.forEach(s => { if (s.weight > b.maxWeight) b.maxWeight = s.weight; if (s.reps > b.maxReps) b.maxReps = s.reps; }); const v = ex.sets.reduce((s, st) => s + st.weight * st.reps, 0); if (v > b.maxVolume) b.maxVolume = v; newPBs[k] = b; });
        persist(prev => ({ ...prev, history: [...prev.history, session], pbs: newPBs }));
        notify("Workout saved! üí™", "success"); setWo(null); setPhase(PHASES.PREP); setScreen("home");
      }

      function quitWorkout() {
        setWo(null); setPhase(PHASES.PREP); setTimer(DEFAULT_TIMERS.prep); setPaused(false); setClock(0); setShowQuit(false); setScreen("home");
        notify("Workout discarded", "warn");
      }

      // Queue reordering ‚Äî move an exercise to be next
      function moveToNext(exIdx) {
        if (exIdx <= wo.currentExIdx) return; // can't move current or past
        setWo(prev => {
          const next = deepClone(prev);
          const targetPos = prev.currentExIdx + 1;
          if (exIdx === targetPos) return prev; // already next
          const [moved] = next.exercises.splice(exIdx, 1);
          next.exercises.splice(targetPos, 0, moved);
          return next;
        });
        notify("Moved to next", "success");
      }

      function moveUp(exIdx) {
        if (exIdx <= wo.currentExIdx + 1) return; // can't move above current+1
        setWo(prev => {
          const next = deepClone(prev);
          const temp = next.exercises[exIdx];
          next.exercises[exIdx] = next.exercises[exIdx - 1];
          next.exercises[exIdx - 1] = temp;
          return next;
        });
      }

      function moveDown(exIdx) {
        if (exIdx <= wo.currentExIdx || exIdx >= wo.exercises.length - 1) return;
        setWo(prev => {
          const next = deepClone(prev);
          const temp = next.exercises[exIdx];
          next.exercises[exIdx] = next.exercises[exIdx + 1];
          next.exercises[exIdx + 1] = temp;
          return next;
        });
      }

      function removeFromQueue(exIdx) {
        if (exIdx <= wo.currentExIdx) return;
        setWo(prev => {
          const next = deepClone(prev);
          next.exercises.splice(exIdx, 1);
          return next;
        });
        notify("Removed from queue", "info");
      }

      function addExercise(bulk) {
        if (!addText.trim()) return;
        const lines = bulk ? addText.split("\n").map(l => l.trim()).filter(Boolean) : [addText.trim()];
        const newExs = lines.map(name => ({ id: genId(), name, muscle: detectMuscle(name), isCardio: isCardio(name), sets: isCardio(name) ? [{ id: genId(), duration: 0, completed: false }] : Array.from({ length: SETS_PER_EXERCISE }, () => ({ id: genId(), weight: 0, reps: 0, completed: false })) }));
        setWo(prev => ({ ...prev, exercises: [...prev.exercises, ...newExs] }));
        setAddText(""); setShowAdd(false); notify(`Added ${newExs.length} exercise(s)`, "success");
      }

      if (!wo) return h("div", { className: "fade-in", style: { padding: "40px 16px", textAlign: "center", maxWidth: 500, margin: "0 auto", paddingBottom: 90 } },
        h("div", { style: { fontSize: 48, marginBottom: 16 } }, "üèãÔ∏è"),
        h("h2", { style: { fontSize: 20, fontWeight: 700, marginBottom: 8 } }, "No Active Workout"),
        h("p", { style: { color: C.textDim, fontSize: 13, marginBottom: 24 } }, "Start a workout from the Home screen or load a Blueprint."),
        h("button", { onClick: () => setScreen("home"), style: { background: C.cyan, color: C.bg, border: "none", borderRadius: 12, padding: "14px 32px", fontSize: 15, fontWeight: 700, cursor: "pointer" } }, "Go Home"),
      );

      const glow = phaseColor[phase] || C.cyan;
      const prog = totalSets > 0 ? doneSets / totalSets : 0;

      return h("div", { style: { minHeight: "100vh", background: C.bg, paddingBottom: 160, maxWidth: 500, margin: "0 auto" } },
        // Top bar with quit button
        h("div", { style: { padding: "12px 16px", display: "flex", justifyContent: "space-between", alignItems: "center", borderBottom: `1px solid ${C.border}` } },
          h("button", { onClick: () => setShowQuit(true), style: { background: "none", border: `1px solid ${C.red}40`, borderRadius: 8, padding: "4px 10px", color: C.red, fontSize: 11, fontWeight: 600, cursor: "pointer" } }, "Quit"),
          h("span", { style: { fontSize: 11, color: C.textDim, fontFamily: "'JetBrains Mono'" } }, `‚è± ${fmtDur(clock)}`),
          h("span", { style: { fontSize: 11, color: C.textDim } }, `${doneSets}/${totalSets} sets`),
          h("button", { onClick: () => { audio.toggle(); notify(audio.enabled ? "Audio ON" : "Audio OFF"); }, style: { background: "none", border: "none", color: audio.enabled ? C.cyan : C.textDim, fontSize: 18, cursor: "pointer" } }, audio.enabled ? "üîä" : "üîá"),
        ),
        // Progress
        h("div", { style: { height: 3, background: C.border } }, h("div", { style: { height: "100%", width: `${prog * 100}%`, background: C.green, transition: "width 0.5s" } })),
        // Timer display
        phase !== PHASES.DONE && curEx && h("div", { className: "fade-in", style: { textAlign: "center", padding: "24px 16px 8px" } },
          h("div", { style: { display: "inline-block", padding: "4px 16px", borderRadius: 20, background: `${glow}15`, border: `1px solid ${glow}40`, color: glow, fontSize: 12, fontWeight: 600, letterSpacing: 1, textTransform: "uppercase", marginBottom: 12 } }, phase.replace("_", " ")),
          h("div", { style: { fontSize: 72, fontWeight: 700, color: glow, fontFamily: "'JetBrains Mono'", animation: timer <= 3 ? "countPulse 0.5s ease infinite" : "none", textShadow: `0 0 40px ${glow}40` } }, fmtTime(timer)),
          h("div", { style: { fontSize: 20, fontWeight: 700, marginTop: 4 } }, curEx.name),
          h("div", { style: { fontSize: 13, color: C.textDim, marginTop: 2 } }, `Set ${wo.currentSetIdx + 1} of ${curEx.sets.length} ‚Ä¢ ${curEx.muscle}`),
        ),
        // Done
        phase === PHASES.DONE && h("div", { style: { textAlign: "center", padding: "40px 16px" } },
          h("div", { style: { fontSize: 48 } }, "üèÜ"),
          h("h2", { style: { fontSize: 28, fontWeight: 800, color: C.green, marginTop: 12 } }, "Complete!"),
          h("p", { style: { color: C.textDim, marginTop: 4 } }, `${fmtDur(clock)} ‚Ä¢ ${doneSets} sets`),
          h("button", { onClick: finish, style: { marginTop: 24, background: C.green, color: C.bg, border: "none", borderRadius: 12, padding: "16px 40px", fontSize: 16, fontWeight: 700, cursor: "pointer" } }, "Save Workout"),
        ),
        // PB & Last Performance display ‚Äî enhanced
        curEx && phase !== PHASES.DONE && !curEx.isCardio && h("div", { style: { padding: "12px 16px 0" } },
          (curPB || lastPerf) && h("div", { style: { display: "flex", gap: 8, marginBottom: 8 } },
            curPB && h("div", { style: { flex: 1, background: `${C.amber}10`, borderRadius: 10, padding: "10px 12px", border: `1px solid ${C.amber}30` } },
              h("div", { style: { fontSize: 10, color: C.amber, textTransform: "uppercase", letterSpacing: 1, marginBottom: 4 } }, "üèÜ All-Time PB"),
              h("div", { style: { fontSize: 14, color: C.text, fontFamily: "'JetBrains Mono'", fontWeight: 600 } }, `${curPB.maxWeight}kg`),
              h("div", { style: { fontSize: 11, color: C.textDim, marginTop: 2 } }, `Best reps: ${curPB.maxReps} ‚Ä¢ Vol: ${curPB.maxVolume}kg`),
            ),
            lastPerf && h("div", { style: { flex: 1, background: `${C.cyan}10`, borderRadius: 10, padding: "10px 12px", border: `1px solid ${C.cyan}30` } },
              h("div", { style: { fontSize: 10, color: C.cyan, textTransform: "uppercase", letterSpacing: 1, marginBottom: 4 } }, "üìÖ Last Session"),
              h("div", { style: { fontSize: 14, color: C.text, fontFamily: "'JetBrains Mono'", fontWeight: 600 } }, `${lastPerf.vol}kg vol`),
              h("div", { style: { fontSize: 11, color: C.textDim, marginTop: 2 } }, lastPerf.sets.map((s, i) => `S${i+1}: ${s.weight}kg√ó${s.reps}`).join(" ‚Ä¢ ")),
            ),
          ),
        ),
        // Set inputs
        curEx && phase !== PHASES.DONE && !curEx.isCardio && h("div", { style: { padding: "4px 16px" } },
          h("div", { style: { background: C.surface, borderRadius: 16, padding: 16, border: `1px solid ${C.border}` } },
            h("div", { style: { display: "flex", flexDirection: "column", gap: 8 } },
              curEx.sets.map((s, si) => h("div", { key: si, style: { display: "flex", gap: 8, alignItems: "center", padding: "8px 10px", borderRadius: 10, background: si === wo.currentSetIdx ? `${glow}10` : "transparent", border: si === wo.currentSetIdx ? `1px solid ${glow}30` : "1px solid transparent", opacity: s.completed ? 0.5 : 1 } },
                h("div", { style: { width: 28, height: 28, borderRadius: "50%", display: "flex", alignItems: "center", justifyContent: "center", fontSize: 12, fontWeight: 700, fontFamily: "'JetBrains Mono'", background: s.completed ? C.green : C.bg, color: s.completed ? C.bg : C.textDim, border: `1px solid ${s.completed ? C.green : C.border}` } }, s.completed ? "‚úì" : si + 1),
                h("div", { style: { flex: 1, display: "flex", gap: 8 } },
                  h("input", { type: "number", inputMode: "decimal", value: s.weight || "", onChange: e => updateSet(wo.currentExIdx, si, "weight", parseFloat(e.target.value) || 0), placeholder: "KG", style: { width: "100%", background: C.bg, border: `1px solid ${C.cyanDim}`, borderRadius: 8, padding: "10px 8px", color: C.cyan, fontSize: 16, fontFamily: "'JetBrains Mono'", textAlign: "center", outline: "none" } }),
                  h("input", { type: "number", inputMode: "numeric", value: s.reps || "", onChange: e => updateSet(wo.currentExIdx, si, "reps", parseInt(e.target.value) || 0), placeholder: "Reps", style: { width: "100%", background: C.bg, border: `1px solid ${C.greenDim}`, borderRadius: 8, padding: "10px 8px", color: C.green, fontSize: 16, fontFamily: "'JetBrains Mono'", textAlign: "center", outline: "none" } }),
                ),
              )),
            ),
          ),
        ),
        // Cardio input
        curEx?.isCardio && phase !== PHASES.DONE && h("div", { style: { padding: "12px 16px" } },
          h("div", { style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}`, textAlign: "center" } },
            h("div", { style: { fontSize: 13, color: C.textDim, marginBottom: 8 } }, "Duration (minutes)"),
            h("input", { type: "number", inputMode: "numeric", value: curEx.sets[0]?.duration || "", onChange: e => updateSet(wo.currentExIdx, 0, "duration", parseInt(e.target.value) || 0), placeholder: "30", style: { width: 120, background: C.bg, border: `1px solid ${C.amberDim}`, borderRadius: 12, padding: 14, color: C.amber, fontSize: 28, fontFamily: "'JetBrains Mono'", textAlign: "center", outline: "none" } }),
          ),
        ),
        // Queue with reorder controls
        h("div", { style: { padding: "8px 16px" } },
          h("div", { style: { fontSize: 11, color: C.textDim, textTransform: "uppercase", letterSpacing: 1, marginBottom: 8, paddingLeft: 4 } }, `Queue (${Math.max(0, wo.exercises.length - wo.currentExIdx - 1)} remaining)`),
          wo.exercises.map((ex, i) => {
            if (i <= wo.currentExIdx) return null;
            const isNext = i === wo.currentExIdx + 1;
            return h("div", { key: ex.id, style: { padding: "10px 12px", borderRadius: 10, background: C.surface, border: `1px solid ${isNext ? C.cyan + "40" : C.border}`, fontSize: 13, color: C.textDim, display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 4 } },
              h("div", { style: { flex: 1, minWidth: 0 } },
                h("span", { style: { color: isNext ? C.cyan : C.textDim, fontWeight: isNext ? 600 : 400 } }, isNext ? "‚ñ∂ " : "", ex.name),
                h("span", { style: { fontSize: 11, marginLeft: 6 } }, ex.isCardio ? "cardio" : `${ex.sets.length}s`),
              ),
              h("div", { style: { display: "flex", gap: 2, flexShrink: 0 } },
                !isNext && h("button", { onClick: () => moveToNext(i), title: "Move to next", style: { background: `${C.cyan}15`, border: `1px solid ${C.cyan}30`, borderRadius: 6, padding: "4px 8px", color: C.cyan, fontSize: 10, fontWeight: 700, cursor: "pointer" } }, "NEXT"),
                h("button", { onClick: () => moveUp(i), title: "Move up", style: { background: "none", border: `1px solid ${C.border}`, borderRadius: 6, padding: "4px 6px", color: C.textDim, fontSize: 12, cursor: "pointer", opacity: i <= wo.currentExIdx + 1 ? 0.3 : 1 } }, "‚Üë"),
                h("button", { onClick: () => moveDown(i), title: "Move down", style: { background: "none", border: `1px solid ${C.border}`, borderRadius: 6, padding: "4px 6px", color: C.textDim, fontSize: 12, cursor: "pointer", opacity: i >= wo.exercises.length - 1 ? 0.3 : 1 } }, "‚Üì"),
                h("button", { onClick: () => removeFromQueue(i), title: "Remove", style: { background: "none", border: `1px solid ${C.red}30`, borderRadius: 6, padding: "4px 6px", color: C.red, fontSize: 11, cursor: "pointer" } }, "‚úï"),
              ),
            );
          }),
        ),
        // Add exercise
        h("div", { style: { padding: "8px 16px" } },
          h("button", { onClick: () => setShowAdd(true), style: { width: "100%", background: "none", border: `1px dashed ${C.border}`, borderRadius: 10, padding: 12, color: C.textDim, cursor: "pointer", fontSize: 13 } }, "+ Add Exercise"),
        ),
        // Add modal
        showAdd && h("div", { style: { position: "fixed", inset: 0, background: "rgba(0,0,0,0.7)", zIndex: 200, display: "flex", alignItems: "center", justifyContent: "center", padding: 20 }, onClick: e => { if (e.target === e.currentTarget) setShowAdd(false); } },
          h("div", { className: "slide-up", style: { background: C.surface, borderRadius: 20, padding: 24, width: "100%", maxWidth: 400, border: `1px solid ${C.border}` } },
            h("h3", { style: { fontSize: 16, fontWeight: 700, marginBottom: 12 } }, "Add Exercises"),
            h("textarea", { value: addText, onChange: e => setAddText(e.target.value), placeholder: "Exercise name\n(one per line for bulk)", rows: 4, autoFocus: true, style: { width: "100%", background: C.bg, border: `1px solid ${C.border}`, borderRadius: 8, padding: 12, color: C.text, fontSize: 14, resize: "none", outline: "none" } }),
            h("div", { style: { display: "flex", gap: 8, marginTop: 12 } },
              h("button", { onClick: () => addExercise(false), style: { flex: 1, background: C.cyan, color: C.bg, border: "none", borderRadius: 10, padding: 12, fontWeight: 700, cursor: "pointer" } }, "Single"),
              h("button", { onClick: () => addExercise(true), style: { flex: 1, background: C.green, color: C.bg, border: "none", borderRadius: 10, padding: 12, fontWeight: 700, cursor: "pointer" } }, "Bulk"),
            ),
          ),
        ),
        // Quit confirmation modal
        showQuit && h("div", { style: { position: "fixed", inset: 0, background: "rgba(0,0,0,0.7)", zIndex: 200, display: "flex", alignItems: "center", justifyContent: "center", padding: 20 }, onClick: e => { if (e.target === e.currentTarget) setShowQuit(false); } },
          h("div", { className: "slide-up", style: { background: C.surface, borderRadius: 20, padding: 24, width: "100%", maxWidth: 360, border: `1px solid ${C.border}`, textAlign: "center" } },
            h("div", { style: { fontSize: 36, marginBottom: 12 } }, "‚ö†Ô∏è"),
            h("h3", { style: { fontSize: 18, fontWeight: 700, marginBottom: 8 } }, "Quit Workout?"),
            h("p", { style: { color: C.textDim, fontSize: 13, marginBottom: 20 } }, "This will discard all progress. Save first if you want to keep it."),
            h("div", { style: { display: "flex", gap: 8 } },
              h("button", { onClick: finish, style: { flex: 1, background: C.green, color: C.bg, border: "none", borderRadius: 10, padding: 14, fontWeight: 700, cursor: "pointer" } }, "Save & End"),
              h("button", { onClick: quitWorkout, style: { flex: 1, background: C.red, color: "#fff", border: "none", borderRadius: 10, padding: 14, fontWeight: 700, cursor: "pointer" } }, "Discard"),
              h("button", { onClick: () => setShowQuit(false), style: { flex: 1, background: C.bg, color: C.textDim, border: `1px solid ${C.border}`, borderRadius: 10, padding: 14, fontWeight: 600, cursor: "pointer" } }, "Cancel"),
            ),
          ),
        ),
        // ACTION ZONE
        phase !== PHASES.DONE && h("div", { style: { position: "fixed", bottom: 56, left: "50%", transform: "translateX(-50%)", width: "100%", maxWidth: 500, padding: "12px 20px", background: `${C.surface}f5`, borderTop: `1px solid ${C.border}`, backdropFilter: "blur(20px)", display: "flex", gap: 12, justifyContent: "center", alignItems: "center", zIndex: 99 } },
          h("button", { onClick: goBack, style: { width: 56, height: 56, borderRadius: "50%", background: C.bg, border: `2px solid ${C.border}`, color: C.text, fontSize: 20, cursor: "pointer", display: "flex", alignItems: "center", justifyContent: "center" } }, "‚èÆ"),
          h("button", { onClick: () => setPaused(!paused), style: { width: 72, height: 72, borderRadius: "50%", background: paused ? C.green : C.amber, border: "none", color: C.bg, fontSize: 26, cursor: "pointer", display: "flex", alignItems: "center", justifyContent: "center", boxShadow: `0 0 30px ${paused ? C.greenDim : C.amberDim}` } }, paused ? "‚ñ∂" : "‚è∏"),
          h("button", { onClick: skip, style: { width: 56, height: 56, borderRadius: "50%", background: C.bg, border: `2px solid ${C.border}`, color: C.text, fontSize: 20, cursor: "pointer", display: "flex", alignItems: "center", justifyContent: "center" } }, "‚è≠"),
        ),
      );
    }

    // ============================================================
    // BLUEPRINTS
    // ============================================================
    function Blueprints() {
      const { db, persist, notify, setWo, setScreen } = useContext(AppCtx);
      const [day, setDay] = useState(DAYS[0]);
      const [editName, setEditName] = useState("");
      const [editExs, setEditExs] = useState("");
      const [editing, setEditing] = useState(false);
      const bp = db.blueprints?.[day];

      function startEdit() { setEditName(bp?.name || `${day} Session`); setEditExs(bp?.exercises?.map(e => e.name).join("\n") || ""); setEditing(true); }
      function updateExMuscle(idx, newMuscle) {
        persist(prev => {
          const bps = { ...prev.blueprints };
          const current = bps[day];
          if (!current) return prev;
          const exs = [...current.exercises];
          exs[idx] = { ...exs[idx], muscle: newMuscle };
          bps[day] = { ...current, exercises: exs };
          return { ...prev, blueprints: bps };
        });
        notify("Muscle group updated", "success");
      }
      function save() {
        const lines = editExs.split("\n").map(l => l.trim()).filter(Boolean);
        const exs = lines.map(name => ({ name, muscle: detectMuscle(name), isCardio: isCardio(name), duration: isCardio(name) ? 30 : undefined }));
        persist(prev => ({ ...prev, blueprints: { ...prev.blueprints, [day]: { name: editName, exercises: exs } } }));
        setEditing(false); notify("Blueprint saved", "success");
      }
      function load() {
        if (!bp?.exercises?.length) return;
        const exs = bp.exercises.map(e => ({ id: genId(), name: e.name, muscle: e.muscle || detectMuscle(e.name), isCardio: isCardio(e.name), sets: isCardio(e.name) ? [{ id: genId(), duration: e.duration || 0, completed: false }] : Array.from({ length: SETS_PER_EXERCISE }, () => ({ id: genId(), weight: 0, reps: 0, completed: false })) }));
        setWo({ id: genId(), exercises: exs, currentExIdx: 0, currentSetIdx: 0, startTime: Date.now() }); setScreen("train"); notify("Blueprint loaded!", "success");
      }

      return h("div", { className: "fade-in", style: { padding: "20px 16px", maxWidth: 500, margin: "0 auto", paddingBottom: 90 } },
        h("h2", { style: { fontSize: 22, fontWeight: 800, marginBottom: 16 } }, "Weekly Blueprint"),
        h("div", { style: { display: "flex", gap: 4, overflowX: "auto", marginBottom: 16, paddingBottom: 4 } },
          DAYS.map(d => h("button", { key: d, onClick: () => { setDay(d); setEditing(false); }, style: { padding: "8px 14px", borderRadius: 10, fontSize: 12, fontWeight: 600, whiteSpace: "nowrap", cursor: "pointer", border: "none", background: day === d ? C.cyan : C.surface, color: day === d ? C.bg : C.textDim } }, d.slice(0, 3))),
        ),
        !editing ? h("div", { style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}` } },
          h("div", { style: { fontSize: 16, fontWeight: 700, marginBottom: 12 } }, bp?.name || `${day} ‚Äî No plan`),
          bp?.exercises?.length > 0 ? h(Fragment, null,
            h("div", { style: { display: "flex", flexDirection: "column", gap: 6, marginBottom: 16 } },
              bp.exercises.map((ex, i) => h("div", { key: i, style: { display: "flex", justifyContent: "space-between", alignItems: "center", padding: "8px 12px", background: C.bg, borderRadius: 8, fontSize: 13 } },
                h("span", { style: { flex: 1 } }, ex.name),
                h("select", { value: ex.muscle || detectMuscle(ex.name), onChange: e => updateExMuscle(i, e.target.value), style: { background: C.surface, border: `1px solid ${C.border}`, borderRadius: 6, padding: "4px 8px", color: C.cyan, fontSize: 11, outline: "none", cursor: "pointer", fontFamily: "'JetBrains Mono'", textTransform: "capitalize" } },
                  MUSCLE_GROUPS.map(m => h("option", { key: m, value: m }, m)),
                  h("option", { value: "other" }, "other"),
                ),
              )),
            ),
            h("div", { style: { display: "flex", gap: 8 } },
              h("button", { onClick: load, style: { flex: 1, background: C.cyan, color: C.bg, border: "none", borderRadius: 10, padding: 14, fontWeight: 700, cursor: "pointer" } }, "Load & Start"),
              h("button", { onClick: startEdit, style: { flex: 1, background: C.bg, color: C.text, border: `1px solid ${C.border}`, borderRadius: 10, padding: 14, fontWeight: 600, cursor: "pointer" } }, "Edit"),
            ),
          ) : h("button", { onClick: startEdit, style: { width: "100%", background: `${C.cyan}15`, border: `1px dashed ${C.cyan}40`, borderRadius: 10, padding: 16, color: C.cyan, cursor: "pointer", fontSize: 14, fontWeight: 600 } }, "+ Create Plan"),
        ) : h("div", { className: "slide-up", style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}` } },
          h("input", { value: editName, onChange: e => setEditName(e.target.value), placeholder: "Session Name", style: { width: "100%", background: C.bg, border: `1px solid ${C.border}`, borderRadius: 8, padding: 12, color: C.text, fontSize: 15, marginBottom: 12, outline: "none" } }),
          h("div", { style: { fontSize: 12, color: C.textDim, marginBottom: 6 } }, "Exercises (one per line):"),
          h("textarea", { value: editExs, onChange: e => setEditExs(e.target.value), rows: 8, placeholder: "Bench Press\nLat Pulldown\nLeg Press", style: { width: "100%", background: C.bg, border: `1px solid ${C.border}`, borderRadius: 8, padding: 12, color: C.text, fontSize: 14, resize: "none", outline: "none" } }),
          h("div", { style: { display: "flex", gap: 8, marginTop: 12 } },
            h("button", { onClick: save, style: { flex: 1, background: C.green, color: C.bg, border: "none", borderRadius: 10, padding: 14, fontWeight: 700, cursor: "pointer" } }, "Save"),
            h("button", { onClick: () => setEditing(false), style: { flex: 1, background: C.bg, color: C.textDim, border: `1px solid ${C.border}`, borderRadius: 10, padding: 14, fontWeight: 600, cursor: "pointer" } }, "Cancel"),
          ),
        ),
      );
    }

    // ============================================================
    // HISTORY
    // ============================================================
    function History() {
      const { db, persist, notify } = useContext(AppCtx);
      const [expanded, setExpanded] = useState(null);
      const [editId, setEditId] = useState(null);
      const [addMuscle, setAddMuscle] = useState("");
      const [addSets, setAddSets] = useState(4);

      const sorted = [...db.history].sort((a, b) => new Date(b.date) - new Date(a.date));

      function addToSession(sid) {
        if (!addMuscle) return;
        persist(prev => ({ ...prev, history: prev.history.map(x => x.id !== sid ? x : { ...x, exercises: [...(x.exercises || []), { name: `${addMuscle} (manual)`, muscle: addMuscle, isCardio: false, sets: Array.from({ length: addSets }, () => ({ weight: 0, reps: 0, completed: true })) }] }) }));
        setEditId(null); setAddMuscle(""); notify("Sets added", "success");
      }
      function removeEx(sid, ei) { persist(prev => ({ ...prev, history: prev.history.map(x => x.id !== sid ? x : { ...x, exercises: x.exercises.filter((_, i) => i !== ei) }) })); notify("Exercise removed", "info"); }

      return h("div", { className: "fade-in", style: { padding: "20px 16px", maxWidth: 500, margin: "0 auto", paddingBottom: 90 } },
        h("h2", { style: { fontSize: 22, fontWeight: 800, marginBottom: 16 } }, "History"),
        sorted.length === 0 && h("div", { style: { textAlign: "center", color: C.textDim, padding: 40 } }, "No workouts yet. Get after it!"),
        sorted.map(x => {
          const isExp = expanded === x.id;
          const vol = (x.exercises || []).reduce((s, e) => s + (e.sets || []).reduce((ss, st) => ss + (st.weight || 0) * (st.reps || 0), 0), 0);
          const muscles = [...new Set((x.exercises || []).map(e => e.muscle))].filter(Boolean);
          return h("div", { key: x.id, style: { background: C.surface, borderRadius: 14, border: `1px solid ${C.border}`, overflow: "hidden", marginBottom: 8 } },
            h("button", { onClick: () => setExpanded(isExp ? null : x.id), style: { width: "100%", background: "none", border: "none", color: C.text, padding: "14px 16px", cursor: "pointer", textAlign: "left", display: "flex", justifyContent: "space-between", alignItems: "center" } },
              h("div", null,
                h("div", { style: { fontSize: 14, fontWeight: 600 } }, new Date(x.date).toLocaleDateString("en-AU", { weekday: "short", month: "short", day: "numeric" })),
                h("div", { style: { fontSize: 11, color: C.textDim, marginTop: 2 } }, `${muscles.join(", ")} ‚Ä¢ ${fmtDur(x.duration || 0)}`),
              ),
              h("div", { style: { textAlign: "right" } },
                h("div", { style: { fontSize: 16, fontWeight: 700, color: C.cyan, fontFamily: "'JetBrains Mono'" } }, vol > 1000 ? `${(vol / 1000).toFixed(1)}k` : vol),
                h("div", { style: { fontSize: 10, color: C.textDim } }, "kg vol"),
              ),
            ),
            isExp && h("div", { className: "slide-up", style: { padding: "0 16px 16px", borderTop: `1px solid ${C.border}` } },
              (x.exercises || []).map((ex, ei) => h("div", { key: ei, style: { marginTop: 10 } },
                h("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center" } },
                  h("span", { style: { fontSize: 13, fontWeight: 600 } }, ex.name),
                  h("button", { onClick: () => removeEx(x.id, ei), style: { background: "none", border: "none", color: C.red, fontSize: 11, cursor: "pointer", padding: "4px 8px" } }, "Remove"),
                ),
                h("div", { style: { display: "flex", gap: 4, flexWrap: "wrap", marginTop: 4 } },
                  (ex.sets || []).map((s, si) => h("span", { key: si, style: { fontSize: 11, color: C.textDim, padding: "2px 8px", background: C.bg, borderRadius: 6 } }, `${s.weight}kg √ó ${s.reps}`)),
                ),
              )),
              editId === x.id ? h("div", { style: { marginTop: 12, padding: 12, background: C.bg, borderRadius: 10 } },
                h("div", { style: { fontSize: 12, color: C.amber, marginBottom: 8 } }, "Add Sets (Correction Mode)"),
                h("select", { value: addMuscle, onChange: e => setAddMuscle(e.target.value), style: { width: "100%", background: C.surface, border: `1px solid ${C.border}`, borderRadius: 8, padding: 10, color: C.text, marginBottom: 8, outline: "none" } },
                  h("option", { value: "" }, "Select muscle group"),
                  MUSCLE_GROUPS.map(m => h("option", { key: m, value: m }, m)),
                ),
                h("div", { style: { display: "flex", gap: 8 } },
                  h("input", { type: "number", value: addSets, onChange: e => setAddSets(parseInt(e.target.value) || 1), style: { width: 60, background: C.surface, border: `1px solid ${C.border}`, borderRadius: 8, padding: 10, color: C.text, textAlign: "center", outline: "none" } }),
                  h("button", { onClick: () => addToSession(x.id), style: { flex: 1, background: C.amber, color: C.bg, border: "none", borderRadius: 8, padding: 10, fontWeight: 700, cursor: "pointer" } }, "Add"),
                ),
              ) : h("button", { onClick: () => setEditId(x.id), style: { marginTop: 10, background: "none", border: `1px dashed ${C.amber}40`, borderRadius: 8, padding: 8, color: C.amber, fontSize: 12, cursor: "pointer", width: "100%" } }, "‚úèÔ∏è Correction Mode"),
            ),
          );
        }),
      );
    }

    // ============================================================
    // ANALYTICS
    // ============================================================
    function Analytics() {
      const { db } = useContext(AppCtx);
      const weeklyData = useMemo(() => {
        const weeks = {};
        db.history.forEach(x => { const d = new Date(x.date); const ws = new Date(d); ws.setDate(d.getDate() - d.getDay() + 1); const k = ws.toISOString().split("T")[0]; if (!weeks[k]) weeks[k] = { sessions: 0, volume: 0 }; weeks[k].sessions++; (x.exercises || []).forEach(ex => { weeks[k].volume += (ex.sets || []).reduce((s, st) => s + (st.weight || 0) * (st.reps || 0), 0); }); });
        return Object.entries(weeks).sort((a, b) => a[0].localeCompare(b[0])).slice(-8);
      }, [db.history]);

      const curVol = weeklyData.length > 0 ? weeklyData[weeklyData.length - 1][1].volume : 0;
      const lastVol = weeklyData.length > 1 ? weeklyData[weeklyData.length - 2][1].volume : 0;
      const change = lastVol > 0 ? ((curVol - lastVol) / lastVol * 100).toFixed(1) : 0;
      const pbs = Object.entries(db.pbs || {}).sort((a, b) => b[1].maxWeight - a[1].maxWeight).slice(0, 10);

      return h("div", { className: "fade-in", style: { padding: "20px 16px", maxWidth: 500, margin: "0 auto", paddingBottom: 90 } },
        h("h2", { style: { fontSize: 22, fontWeight: 800, marginBottom: 16 } }, "Analytics"),
        // Volume trend
        h("div", { style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}`, marginBottom: 12 } },
          h("div", { style: { fontSize: 11, color: C.textDim, textTransform: "uppercase", letterSpacing: 1, marginBottom: 12 } }, "Volume Trend"),
          h("div", { style: { display: "flex", gap: 16, alignItems: "flex-end" } },
            h("div", { style: { flex: 1 } }, h("div", { style: { fontSize: 11, color: C.textDim, marginBottom: 4 } }, "This Week"), h("div", { style: { fontSize: 28, fontWeight: 700, color: C.cyan, fontFamily: "'JetBrains Mono'" } }, curVol > 1000 ? `${(curVol / 1000).toFixed(1)}k` : curVol)),
            h("div", { style: { flex: 1 } }, h("div", { style: { fontSize: 11, color: C.textDim, marginBottom: 4 } }, "Last Week"), h("div", { style: { fontSize: 28, fontWeight: 700, color: C.textDim, fontFamily: "'JetBrains Mono'" } }, lastVol > 1000 ? `${(lastVol / 1000).toFixed(1)}k` : lastVol)),
            h("div", { style: { padding: "6px 14px", borderRadius: 20, fontSize: 14, fontWeight: 700, background: change >= 0 ? C.greenDim : C.redDim, color: change >= 0 ? C.green : C.red } }, `${change >= 0 ? "‚Üë" : "‚Üì"} ${Math.abs(change)}%`),
          ),
        ),
        // Chart
        weeklyData.length > 0 && h("div", { style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}`, marginBottom: 12 } },
          h("div", { style: { fontSize: 11, color: C.textDim, textTransform: "uppercase", letterSpacing: 1, marginBottom: 16 } }, "Weekly Volume"),
          h("div", { style: { display: "flex", gap: 4, alignItems: "flex-end", height: 120 } },
            weeklyData.map(([w, d], i) => {
              const max = Math.max(...weeklyData.map(x => x[1].volume), 1);
              const ht = (d.volume / max) * 100;
              return h("div", { key: w, style: { flex: 1, display: "flex", flexDirection: "column", alignItems: "center", gap: 4 } },
                h("div", { style: { fontSize: 9, color: C.textDim } }, d.volume > 1000 ? `${(d.volume / 1000).toFixed(0)}k` : d.volume),
                h("div", { style: { width: "100%", height: `${ht}%`, minHeight: 4, background: i === weeklyData.length - 1 ? C.cyan : C.border, borderRadius: 4 } }),
                h("div", { style: { fontSize: 9, color: C.textDim } }, new Date(w).toLocaleDateString("en-AU", { day: "numeric", month: "short" })),
              );
            }),
          ),
        ),
        // PBs
        h("div", { style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}` } },
          h("div", { style: { fontSize: 11, color: C.textDim, textTransform: "uppercase", letterSpacing: 1, marginBottom: 12 } }, "üèÜ Personal Bests"),
          pbs.length === 0 && h("div", { style: { color: C.textDim, fontSize: 13 } }, "No PBs recorded yet"),
          pbs.map(([name, pb]) => h("div", { key: name, style: { display: "flex", justifyContent: "space-between", alignItems: "center", padding: "8px 12px", background: C.bg, borderRadius: 8, marginBottom: 4 } },
            h("span", { style: { fontSize: 13, fontWeight: 500, textTransform: "capitalize" } }, name),
            h("div", { style: { display: "flex", gap: 12 } },
              h("span", { style: { fontSize: 12, color: C.cyan, fontFamily: "'JetBrains Mono'" } }, `${pb.maxWeight}kg`),
              h("span", { style: { fontSize: 12, color: C.green, fontFamily: "'JetBrains Mono'" } }, `${pb.maxReps}r`),
              h("span", { style: { fontSize: 12, color: C.amber, fontFamily: "'JetBrains Mono'" } }, `${pb.maxVolume}v`),
            ),
          )),
        ),
      );
    }

    // ============================================================
    // SETTINGS
    // ============================================================
    function Settings() {
      const { db, persist, notify } = useContext(AppCtx);
      const t = db.settings?.timers || DEFAULT_TIMERS;
      function upd(k, v) { persist(prev => ({ ...prev, settings: { ...prev.settings, timers: { ...(prev.settings?.timers || DEFAULT_TIMERS), [k]: parseInt(v) || 0 } } })); }
      function clearAll() { if (confirm("This will erase ALL data. Are you sure?")) { persist(emptyDB()); notify("All data cleared", "warn"); } }
      const fields = [{ key: "prep", label: "Prep Timer", color: C.amber }, { key: "work", label: "Work Timer", color: C.cyan }, { key: "restSet", label: "Rest (Set)", color: C.green }, { key: "restEx", label: "Rest (Exercise)", color: C.purple }];

      return h("div", { className: "fade-in", style: { padding: "20px 16px", maxWidth: 500, margin: "0 auto", paddingBottom: 90 } },
        h("h2", { style: { fontSize: 22, fontWeight: 800, marginBottom: 16 } }, "Settings"),
        h("div", { style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}`, marginBottom: 12 } },
          h("div", { style: { fontSize: 13, fontWeight: 600, marginBottom: 14 } }, "Timer Defaults (seconds)"),
          fields.map(f => h("div", { key: f.key, style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 10 } },
            h("span", { style: { fontSize: 13, color: f.color } }, f.label),
            h("input", { type: "number", value: t[f.key], onChange: e => upd(f.key, e.target.value), style: { width: 80, background: C.bg, border: `1px solid ${C.border}`, borderRadius: 8, padding: "8px 12px", color: C.text, fontSize: 14, fontFamily: "'JetBrains Mono'", textAlign: "center", outline: "none" } }),
          )),
        ),
        h("button", { onClick: clearAll, style: { width: "100%", background: C.surface, border: `1px solid ${C.red}30`, borderRadius: 12, padding: 14, color: C.red, cursor: "pointer", fontSize: 13, fontWeight: 600 } }, "‚ö†Ô∏è Clear All Data"),
      );
    }

    // ============================================================
    // EXPORT
    // ============================================================
    function Export() {
      const { db, setScreen } = useContext(AppCtx);
      const [copied, setCopied] = useState(false);
      const data = useMemo(() => ({
        meta: { app: "RepVault", version: "2.0", exportedAt: new Date().toISOString(), format: "ai-ready" },
        summary: { totalSessions: db.history.length, totalExercises: db.history.reduce((s, x) => s + (x.exercises?.length || 0), 0), dateRange: db.history.length > 0 ? { from: db.history[0]?.date, to: db.history[db.history.length - 1]?.date } : null },
        personalBests: db.pbs, weeklyBlueprints: db.blueprints,
        history: db.history.map(x => ({ date: x.date, duration: x.duration, exercises: (x.exercises || []).map(ex => ({ name: ex.name, muscle: ex.muscle, sets: ex.sets, totalVolume: (ex.sets || []).reduce((s, st) => s + (st.weight || 0) * (st.reps || 0), 0) })), sessionVolume: (x.exercises || []).reduce((s, ex) => s + (ex.sets || []).reduce((ss, st) => ss + (st.weight || 0) * (st.reps || 0), 0), 0) })),
      }), [db]);

      function copy() { navigator.clipboard?.writeText(JSON.stringify(data, null, 2)); setCopied(true); setTimeout(() => setCopied(false), 2000); }

      return h("div", { className: "fade-in", style: { padding: "20px 16px", maxWidth: 500, margin: "0 auto", paddingBottom: 90 } },
        h("div", { style: { display: "flex", alignItems: "center", gap: 12, marginBottom: 16 } },
          h("button", { onClick: () => setScreen("home"), style: { background: "none", border: "none", color: C.textDim, fontSize: 20, cursor: "pointer" } }, "‚Üê"),
          h("h2", { style: { fontSize: 22, fontWeight: 800 } }, "AI-Ready Export"),
        ),
        h("div", { style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}`, marginBottom: 12 } },
          h("div", { style: { fontSize: 13, color: C.textDim, marginBottom: 12 } }, "Structured JSON for LLM consumption. Paste into Gemini, Claude, or ChatGPT for fatigue analysis and programming recommendations."),
          h("div", { style: { display: "flex", gap: 8, flexWrap: "wrap", marginBottom: 16 } },
            h("span", { style: { fontSize: 11, padding: "4px 10px", background: C.cyanDim, color: C.cyan, borderRadius: 20 } }, `${data.summary.totalSessions} sessions`),
            h("span", { style: { fontSize: 11, padding: "4px 10px", background: C.greenDim, color: C.green, borderRadius: 20 } }, `${data.summary.totalExercises} exercises`),
            h("span", { style: { fontSize: 11, padding: "4px 10px", background: C.amberDim, color: C.amber, borderRadius: 20 } }, `${Object.keys(db.pbs || {}).length} PBs`),
          ),
          h("button", { onClick: copy, style: { width: "100%", background: copied ? C.green : C.cyan, color: C.bg, border: "none", borderRadius: 12, padding: 16, fontSize: 15, fontWeight: 700, cursor: "pointer", transition: "background 0.3s" } }, copied ? "‚úì Copied!" : "üìã Copy JSON to Clipboard"),
        ),
        h("div", { style: { background: C.surface, borderRadius: 16, padding: 16, border: `1px solid ${C.border}` } },
          h("div", { style: { fontSize: 11, color: C.textDim, marginBottom: 8, textTransform: "uppercase", letterSpacing: 1 } }, "Preview"),
          h("pre", { style: { fontSize: 10, color: C.textDim, overflow: "auto", maxHeight: 300, fontFamily: "'JetBrains Mono'", lineHeight: 1.4 } }, JSON.stringify(data, null, 2).slice(0, 2000)),
        ),
      );
    }

    // --- Mount ---
    ReactDOM.createRoot(document.getElementById("root")).render(React.createElement(App));

    // --- Register Service Worker ---
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("sw.js").catch(err => console.log("SW registration failed:", err));
      });
    }
  </script>
</body>
</html>
