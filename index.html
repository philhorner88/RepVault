<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>RepVault</title>

  <!-- PWA Meta -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0a0a0f">
  <meta name="background-color" content="#0a0a0f">

  <!-- iOS PWA Meta -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="RepVault">
  <link rel="apple-touch-icon" href="icon-192.png">

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Outfit:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
    body {
      background: #0a0a0f; color: #e8e8f0; font-family: 'Outfit', sans-serif;
      overflow-x: hidden; -webkit-font-smoothing: antialiased;
      padding-top: env(safe-area-inset-top);
    }
    input, select, textarea { font-family: 'JetBrains Mono', monospace; }
    ::-webkit-scrollbar { width: 4px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #2a2a3a; border-radius: 2px; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes slideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes countPulse { 0% { transform: scale(1); } 50% { transform: scale(1.08); } 100% { transform: scale(1); } }
    @keyframes ringGlow { 0%,100% { filter: drop-shadow(0 0 12px var(--glow-color, rgba(0,229,255,0.25))); } 50% { filter: drop-shadow(0 0 25px var(--glow-color, rgba(0,229,255,0.25))); } }
    @keyframes pulseDot { 0%,100% { opacity: 1; } 50% { opacity: 0.5; } }
    .fade-in { animation: fadeIn 0.3s ease-out; }
    .slide-up { animation: slideUp 0.4s ease-out; }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- React via CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>

  <script>
    // ============================================================
    // REPVAULT - Production PWA Build
    // ============================================================
    const { useState, useEffect, useRef, useCallback, useMemo, createContext, useContext, createElement: h, Fragment } = React;

    const STORAGE_KEY = "repvault_v2_master";
    const PHASES = { PREP: "PREP", WORK: "WORK", REST_SET: "REST_SET", REST_EX: "REST_EX", DONE: "DONE" };
    const DEFAULT_TIMERS = { prep: 10, work: 45, restSet: 60, restEx: 60 };
    const SETS_PER_EXERCISE = 4;
    const DAYS = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
    const CRASH_KEY = "repvault_active_workout";

    // Muscle groups â€” order matters: more specific phrases checked first
    const MUSCLE_GROUPS = ["chest", "back", "shoulders", "glutes", "quads", "hamstrings", "calves", "biceps", "triceps", "core", "cardio"];
    const MUSCLE_RULES = [
      // Multi-word phrases first (most specific wins)
      { phrase: "chest supported row", group: "back" },
      { phrase: "chest-supported row", group: "back" },
      { phrase: "t-bar row", group: "back" },
      { phrase: "t bar row", group: "back" },
      { phrase: "cable row", group: "back" },
      { phrase: "barbell row", group: "back" },
      { phrase: "dumbbell row", group: "back" },
      { phrase: "pendlay row", group: "back" },
      { phrase: "seated row", group: "back" },
      { phrase: "bent over row", group: "back" },
      { phrase: "upright row", group: "shoulders" },
      { phrase: "face pull", group: "back" },
      { phrase: "rear delt", group: "back" },
      { phrase: "back ext", group: "back" },
      { phrase: "lat pulldown", group: "back" },
      { phrase: "wide-grip lat", group: "back" },
      { phrase: "close-grip lat", group: "back" },
      { phrase: "pull up", group: "back" },
      { phrase: "pullup", group: "back" },
      { phrase: "chin up", group: "back" },
      { phrase: "chinup", group: "back" },
      { phrase: "pulldown", group: "back" },
      { phrase: "shoulder press", group: "shoulders" },
      { phrase: "overhead press", group: "shoulders" },
      { phrase: "ohp", group: "shoulders" },
      { phrase: "military press", group: "shoulders" },
      { phrase: "arnold press", group: "shoulders" },
      { phrase: "lateral raise", group: "shoulders" },
      { phrase: "front raise", group: "shoulders" },
      { phrase: "delt", group: "shoulders" },
      { phrase: "shoulder", group: "shoulders" },
      { phrase: "bench press", group: "chest" },
      { phrase: "chest fly", group: "chest" },
      { phrase: "chest press", group: "chest" },
      { phrase: "cable fly", group: "chest" },
      { phrase: "crossover", group: "chest" },
      { phrase: "pec deck", group: "chest" },
      { phrase: "pec", group: "chest" },
      { phrase: "push up", group: "chest" },
      { phrase: "pushup", group: "chest" },
      { phrase: "incline dumbbell", group: "chest" },
      { phrase: "decline dumbbell", group: "chest" },
      { phrase: "fly", group: "chest" },
      { phrase: "flye", group: "chest" },
      { phrase: "bench", group: "chest" },
      { phrase: "hip thrust", group: "glutes" },
      { phrase: "glute bridge", group: "glutes" },
      { phrase: "glute", group: "glutes" },
      { phrase: "kickback", group: "glutes" },
      { phrase: "leg curl", group: "hamstrings" },
      { phrase: "hamstring", group: "hamstrings" },
      { phrase: "rdl", group: "hamstrings" },
      { phrase: "romanian deadlift", group: "hamstrings" },
      { phrase: "stiff leg", group: "hamstrings" },
      { phrase: "good morning", group: "hamstrings" },
      { phrase: "nordic", group: "hamstrings" },
      { phrase: "leg ext", group: "quads" },
      { phrase: "leg extension", group: "quads" },
      { phrase: "leg press", group: "quads" },
      { phrase: "squat", group: "quads" },
      { phrase: "split squat", group: "quads" },
      { phrase: "lunge", group: "quads" },
      { phrase: "step up", group: "quads" },
      { phrase: "goblet", group: "quads" },
      { phrase: "hack squat", group: "quads" },
      { phrase: "quad", group: "quads" },
      { phrase: "calf raise", group: "calves" },
      { phrase: "calf", group: "calves" },
      { phrase: "bicep curl", group: "biceps" },
      { phrase: "bicep", group: "biceps" },
      { phrase: "hammer curl", group: "biceps" },
      { phrase: "preacher", group: "biceps" },
      { phrase: "concentration curl", group: "biceps" },
      { phrase: "curl", group: "biceps" },
      { phrase: "tricep", group: "triceps" },
      { phrase: "pushdown", group: "triceps" },
      { phrase: "skull crush", group: "triceps" },
      { phrase: "close grip", group: "triceps" },
      { phrase: "extension", group: "triceps" },
      { phrase: "dip", group: "chest" },
      { phrase: "deadlift", group: "back" },
      { phrase: "shrug", group: "back" },
      { phrase: "row", group: "back" },
      { phrase: "pull", group: "back" },
      { phrase: "lat", group: "back" },
      { phrase: "press", group: "chest" },
      { phrase: "crunch", group: "core" },
      { phrase: "plank", group: "core" },
      { phrase: "sit up", group: "core" },
      { phrase: "situp", group: "core" },
      { phrase: "oblique", group: "core" },
      { phrase: "russian twist", group: "core" },
      { phrase: "leg raise", group: "core" },
      { phrase: "hollow", group: "core" },
      { phrase: "woodchop", group: "core" },
      { phrase: "pallof", group: "core" },
      { phrase: "ab ", group: "core" },
      { phrase: "core", group: "core" },
    ];
    const CARDIO_LIST = ["run", "bike", "swim", "cycle", "jog", "sprint", "elliptical", "stair", "walk", "treadmill", "rowing machine", "hiit"];

    function detectMuscle(name) {
      const l = normaliseName(name);
      for (const rule of MUSCLE_RULES) { if (l.includes(rule.phrase)) return rule.group; }
      if (CARDIO_LIST.some(k => l.includes(k))) return "cardio";
      return "other";
    }
    function isCardio(name) { const l = normaliseName(name); return CARDIO_LIST.some(k => l.includes(k)); }

    // --- Name normalisation: DB=Dumbbell, BB=Barbell, etc ---
    const NAME_ALIASES = [
      [/\bdb\b/gi, "dumbbell"], [/\bbb\b/gi, "barbell"], [/\bsm\b/gi, "smith machine"],
      [/\boh\b/gi, "overhead"], [/\brdl\b/gi, "romanian deadlift"], [/\bsldl\b/gi, "stiff leg deadlift"],
      [/\bincl\b/gi, "incline"], [/\bdecl\b/gi, "decline"],
    ];
    function normaliseName(name) {
      let n = name.toLowerCase().trim();
      NAME_ALIASES.forEach(([rx, rep]) => { n = n.replace(rx, rep); });
      return n;
    }
    // Canonical key for PB lookups â€” ensures "DB shoulder press" matches "Dumbbell shoulder press"
    function pbKey(name) { return normaliseName(name); }

    // --- Week boundary: Monday 00:00 AEST (UTC+10) ---
    function getMonday(date) {
      const d = new Date(date);
      // Adjust to AEST (UTC+10)
      const aest = new Date(d.getTime() + (10 * 60 * 60 * 1000));
      const day = aest.getUTCDay(); // 0=Sun, 1=Mon
      const diff = day === 0 ? 6 : day - 1; // days since Monday
      aest.setUTCDate(aest.getUTCDate() - diff);
      aest.setUTCHours(0, 0, 0, 0);
      // Convert back to UTC
      return new Date(aest.getTime() - (10 * 60 * 60 * 1000));
    }
    function thisMonday() { return getMonday(new Date()); }
    function thisMonthStart() {
      const d = new Date();
      const aest = new Date(d.getTime() + (10 * 60 * 60 * 1000));
      return new Date(Date.UTC(aest.getUTCFullYear(), aest.getUTCMonth(), 1) - (10 * 60 * 60 * 1000));
    }

    function deepClone(o) { try { return JSON.parse(JSON.stringify(o, (_, v) => typeof v === "number" && isNaN(v) ? null : v)); } catch { return {}; } }
    function genId() { return Date.now().toString(36) + Math.random().toString(36).slice(2, 8); }
    function fmtTime(s) { if (s < 0) s = 0; return `${Math.floor(s / 60)}:${Math.floor(s % 60).toString().padStart(2, "0")}`; }
    function fmtDur(s) { const hr = Math.floor(s / 3600), m = Math.floor((s % 3600) / 60), sec = Math.floor(s % 60); return hr > 0 ? `${hr}h ${m}m` : m > 0 ? `${m}m ${sec}s` : `${sec}s`; }

    const C = {
      bg: "#0a0a0f", surface: "#12121a", surfaceLight: "#1a1a28", border: "#2a2a3a",
      text: "#e8e8f0", textDim: "#8888a0",
      cyan: "#00e5ff", cyanDim: "#00e5ff40", green: "#39ff14", greenDim: "#39ff1440",
      amber: "#ffb300", amberDim: "#ffb30040", red: "#ff3d3d", redDim: "#ff3d3d40", purple: "#b388ff", purpleDim: "#b388ff40",
      gold: "#ffc850", goldDim: "#ffc85040",
    };
    const phaseColor = { [PHASES.PREP]: C.amber, [PHASES.WORK]: C.cyan, [PHASES.REST_SET]: C.green, [PHASES.REST_EX]: C.purple, [PHASES.DONE]: C.green };

    // --- Storage ---
    const SEED_PBS = {
      "standing calf raise": { maxWeight: 136, maxReps: 10, maxVolume: 2460 },
      "flat dumbbell bench press": { maxWeight: 70, maxReps: 9, maxVolume: 1890 },
      "incline dumbbell bench press": { maxWeight: 60, maxReps: 10, maxVolume: 1860 },
      "leg curl": { maxWeight: 45, maxReps: 10, maxVolume: 1620 },
      "seated dumbbell shoulder press": { maxWeight: 44, maxReps: 10, maxVolume: 1500 },
      "chest-supported row": { maxWeight: 40, maxReps: 10, maxVolume: 1600 },
      "smith machine split squat": { maxWeight: 40, maxReps: 10, maxVolume: 1360 },
      "split squat": { maxWeight: 40, maxReps: 10, maxVolume: 1040 },
      "cable chest fly": { maxWeight: 27, maxReps: 10, maxVolume: 905 },
      "incline fly": { maxWeight: 20, maxReps: 8, maxVolume: 334 },
    };
    function mkBPEx(name) { return { name, muscle: detectMuscle(name), isCardio: isCardio(name) }; }
    const SEED_BLUEPRINTS = {
      Monday: { name: "Workout A â€“ Upper Emphasis", exercises: [
        "Pallof Press", "Dead Bug", "Flat Dumbbell Bench Press", "Chest-Supported Row",
        "Seated Dumbbell Shoulder Press", "Wide-Grip Lat Pulldown", "Incline Dumbbell Bench Press",
        "Cable Chest Fly", "Hip Thrust", "Leg Extension",
        "Smith Machine Split Squat", "Leg Curl", "Standing Calf Raise"
      ].map(mkBPEx) },
      Tuesday: { name: "Workout B â€“ Lower Emphasis", exercises: [
        "McGill Curl-Up", "Leg Press", "Glute Kickback (Cable)", "Leg Curl (Seated)",
        "Smith Machine Split Squat (Long Stride)", "Seated Calf Raise",
        "Machine Chest Press", "Pec Deck", "Neutral-Grip Lat Pulldown",
        "Cable Lateral Raise", "Rear-Delt Cable Fly", "EZ-Bar Curl", "Rope Triceps Pushdown"
      ].map(mkBPEx) },
      Thursday: { name: "Workout C â€“ Upper Emphasis", exercises: [
        "Hanging Knee Raise", "Plank Hold", "Incline Dumbbell Fly", "Seated Cable Row",
        "Dumbbell Shoulder Press", "One-Arm Dumbbell Row", "Close-Grip Bench Press",
        "Straight-Arm Pulldown", "Leg Extension", "Hip Thrust (Single-Leg)",
        "Leg Curl", "Smith Machine Split Squat (Short Stride)", "Standing Calf Raise", "Face Pulls"
      ].map(mkBPEx) },
      Friday: { name: "Workout D â€“ Lower Emphasis", exercises: [
        "Russian Twist", "Hip Thrust", "Leg Extension (Tempo)",
        "Glute Kickback (Cable)", "Leg Curl (Single-Leg)", "Seated Calf Raise",
        "Machine Chest Press", "Chest-Supported T-Bar Row", "Cable Lateral Raise",
        "Reverse Pec Deck", "Skull Crushers", "Incline Dumbbell Curl", "Barbell Curl"
      ].map(mkBPEx) },
    };
    function loadDB() {
      try {
        const d = localStorage.getItem(STORAGE_KEY);
        if (d) {
          const parsed = JSON.parse(d);
          let changed = false;
          if (!parsed._pbSeeded) { parsed.pbs = { ...SEED_PBS, ...(parsed.pbs || {}) }; parsed._pbSeeded = true; changed = true; }
          if (!parsed._bpSeeded) { parsed.blueprints = { ...SEED_BLUEPRINTS, ...(parsed.blueprints || {}) }; parsed._bpSeeded = true; changed = true; }
          if (changed) saveDB(parsed);
          return parsed;
        }
      } catch {}
      // Legacy scan
      try {
        const keys = ["ironfocus_data", "ironfocus_history", "ironfocus_blueprints", "ironfocus_v2_master"];
        let merged = emptyDB();
        for (const k of keys) {
          try { const r = localStorage.getItem(k); if (r) { const d = JSON.parse(r); if (d.history) merged.history.push(...d.history); if (d.blueprints) Object.assign(merged.blueprints, d.blueprints); if (d.pbs) Object.assign(merged.pbs, d.pbs); } } catch {}
        }
        if (merged.history.length > 0 || Object.keys(merged.blueprints).length > 0) return merged;
      } catch {}
      const fresh = emptyDB();
      fresh.pbs = { ...SEED_PBS };
      fresh.blueprints = { ...SEED_BLUEPRINTS };
      fresh._pbSeeded = true;
      fresh._bpSeeded = true;
      return fresh;
    }
    function saveDB(db) { try { localStorage.setItem(STORAGE_KEY, JSON.stringify(deepClone(db))); } catch (e) { console.error("Save failed:", e); } }
    function emptyDB() { return { history: [], blueprints: {}, pbs: {}, settings: { timers: { ...DEFAULT_TIMERS }, audioEnabled: true } }; }

    // --- Crash Recovery ---
    function saveActiveWorkout(wo, phase, clock) {
      if (!wo) { clearActiveWorkout(); return; }
      try { localStorage.setItem(CRASH_KEY, JSON.stringify({ wo: deepClone(wo), phase, clock, savedAt: Date.now() })); } catch (e) { console.error("Crash save failed:", e); }
    }
    function loadActiveWorkout() {
      try { const d = localStorage.getItem(CRASH_KEY); if (!d) return null; const snap = JSON.parse(d); if (Date.now() - snap.savedAt > 12 * 60 * 60 * 1000) { clearActiveWorkout(); return null; } return snap; } catch { return null; }
    }
    function clearActiveWorkout() { try { localStorage.removeItem(CRASH_KEY); } catch {} }

    const phaseLabel = { [PHASES.PREP]: "GET READY", [PHASES.WORK]: "WORK", [PHASES.REST_SET]: "REST BETWEEN SETS", [PHASES.REST_EX]: "REST BETWEEN EXERCISES", [PHASES.DONE]: "DONE" };

    // --- Audio Engine ---
    class AudioEngine {
      constructor() { this.ctx = null; this.enabled = true; this.hb = null; }
      init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); if (this.ctx.state === "suspended") this.ctx.resume(); }
      pip(f = 880, d = 0.08) { if (!this.enabled || !this.ctx) return; const o = this.ctx.createOscillator(), g = this.ctx.createGain(); o.connect(g); g.connect(this.ctx.destination); o.frequency.value = f; o.type = "sine"; g.gain.setValueAtTime(0.3, this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + d); o.start(this.ctx.currentTime); o.stop(this.ctx.currentTime + d); }
      countdownPip() { this.pip(1200, 0.06); }
      phasePip() { this.pip(660, 0.15); }
      speak(t) { if (!this.enabled || !window.speechSynthesis) return; window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(t); u.rate = 1.1; u.pitch = 0.9; u.volume = 0.8; window.speechSynthesis.speak(u); }
      startHeartbeat() { if (this.hb) return; this.init(); this.hb = setInterval(() => { if (!this.ctx) return; const o = this.ctx.createOscillator(), g = this.ctx.createGain(); o.connect(g); g.connect(this.ctx.destination); g.gain.setValueAtTime(0.001, this.ctx.currentTime); o.start(this.ctx.currentTime); o.stop(this.ctx.currentTime + 0.01); }, 10000); }
      stopHeartbeat() { if (this.hb) { clearInterval(this.hb); this.hb = null; } }
      toggle() { this.enabled = !this.enabled; return this.enabled; }
    }
    const audio = new AudioEngine();

    function updateMedia(title, artist) { if ("mediaSession" in navigator) { try { navigator.mediaSession.metadata = new MediaMetadata({ title, artist, album: "RepVault" }); } catch {} } }

    const AppCtx = createContext(null);

    // --- Ring Timer SVG Component ---
    function RingTimer({ seconds, total, color, size = 170 }) {
      const r = (size - 6) / 2;
      const circ = 2 * Math.PI * r;
      const progress = total > 0 ? Math.max(0, Math.min(1, seconds / total)) : 0;
      const offset = circ * (1 - progress);
      return h("svg", { width: size, height: size, viewBox: `0 0 ${size} ${size}`, style: { transform: "rotate(-90deg)", "--glow-color": `${color}40`, animation: "ringGlow 3s ease infinite" } },
        h("circle", { cx: size/2, cy: size/2, r, fill: "none", stroke: C.border, strokeWidth: 2.5 }),
        h("circle", { cx: size/2, cy: size/2, r, fill: "none", stroke: color, strokeWidth: 2.5, strokeLinecap: "round", strokeDasharray: circ, strokeDashoffset: offset, style: { filter: `drop-shadow(0 0 6px ${color}50)`, transition: "stroke-dashoffset 0.15s linear" } }),
      );
    }

    // ============================================================
    // MAIN APP
    // ============================================================
    function App() {
      const [db, setDb] = useState(() => loadDB());
      const [screen, setScreen] = useState("home");
      const [wo, setWo] = useState(null);
      const [notif, setNotif] = useState(null);
      const [phase, setPhase] = useState(PHASES.PREP);
      const [timer, setTimer] = useState(DEFAULT_TIMERS.prep);
      const [paused, setPaused] = useState(false);
      const [clock, setClock] = useState(0);
      const [showRestore, setShowRestore] = useState(false);
      const crashSnap = useRef(null);

      // Check for crashed workout on mount
      useEffect(() => {
        const snap = loadActiveWorkout();
        if (snap && snap.wo) { crashSnap.current = snap; setShowRestore(true); }
      }, []);

      function restoreWorkout() {
        const snap = crashSnap.current;
        if (!snap) return;
        const restoredWo = snap.wo;
        const totalElapsed = snap.clock + Math.floor((Date.now() - snap.savedAt) / 1000);
        restoredWo.startTime = Date.now() - totalElapsed * 1000;
        setWo(restoredWo); setPhase(snap.phase === PHASES.DONE ? PHASES.DONE : PHASES.WORK);
        setTimer(0); setClock(totalElapsed); setPaused(true); setScreen("train");
        setShowRestore(false); crashSnap.current = null;
        notify("Workout restored! ðŸ’ª Paused â€” tap play when ready.", "success");
      }
      function dismissRestore() { clearActiveWorkout(); setShowRestore(false); crashSnap.current = null; }

      const persist = useCallback((updater) => {
        setDb(prev => { const next = typeof updater === "function" ? updater(prev) : updater; saveDB(next); return next; });
      }, []);
      const notify = useCallback((msg, type = "info") => { setNotif({ msg, type, id: Date.now() }); setTimeout(() => setNotif(null), 2500); }, []);

      const ctx = { db, persist, notify, screen, setScreen, wo, setWo, phase, setPhase, timer, setTimer, paused, setPaused, clock, setClock };

      return h(AppCtx.Provider, { value: ctx },
        notif && h(Toast, notif),
        // Crash restore modal
        showRestore && h("div", { style: { position: "fixed", inset: 0, background: "rgba(0,0,0,0.85)", zIndex: 300, display: "flex", alignItems: "center", justifyContent: "center", padding: 20 } },
          h("div", { className: "slide-up", style: { background: C.surface, borderRadius: 20, padding: 28, width: "100%", maxWidth: 360, border: `1px solid ${C.green}40`, textAlign: "center" } },
            h("div", { style: { fontSize: 48, marginBottom: 12 } }, "ðŸ”„"),
            h("h3", { style: { fontSize: 18, fontWeight: 700, marginBottom: 8 } }, "Workout Recovery"),
            h("p", { style: { color: C.textDim, fontSize: 13, marginBottom: 6, lineHeight: 1.5 } }, "Found an interrupted workout session."),
            crashSnap.current && h("div", { style: { background: C.bg, borderRadius: 10, padding: 12, marginBottom: 16, border: `1px solid ${C.border}` } },
              h("div", { style: { fontSize: 14, fontWeight: 600, marginBottom: 4 } }, `${crashSnap.current.wo.exercises?.length || 0} exercises`),
              h("div", { style: { fontSize: 12, color: C.textDim } }, `${fmtDur(crashSnap.current.clock)} elapsed â€¢ ${crashSnap.current.wo.exercises?.reduce((s, e) => s + e.sets.filter(x => x.completed).length, 0) || 0} sets done`),
            ),
            h("div", { style: { display: "flex", gap: 8 } },
              h("button", { onClick: restoreWorkout, style: { flex: 1, background: C.green, color: C.bg, border: "none", borderRadius: 12, padding: 14, fontWeight: 700, cursor: "pointer", fontSize: 14 } }, "Restore"),
              h("button", { onClick: dismissRestore, style: { flex: 1, background: C.bg, color: C.textDim, border: `1px solid ${C.border}`, borderRadius: 12, padding: 14, fontWeight: 600, cursor: "pointer", fontSize: 14 } }, "Discard"),
            ),
          ),
        ),
        screen === "home" && h(Home),
        screen === "train" && h(Train),
        screen === "blueprints" && h(Blueprints),
        screen === "history" && h(History),
        screen === "analytics" && h(Analytics),
        screen === "settings" && h(Settings),
        screen === "export" && h(Export),
        h(NavBar),
      );
    }

    // --- Toast ---
    function Toast({ msg, type }) {
      const colors = { info: C.cyan, success: C.green, error: C.red, warn: C.amber };
      return h("div", { className: "slide-up", style: {
        position: "fixed", top: 16, left: "50%", transform: "translateX(-50%)", background: C.surface,
        border: `1px solid ${colors[type] || C.cyan}`, color: colors[type] || C.cyan,
        padding: "10px 20px", borderRadius: 12, fontSize: 13, fontWeight: 500, zIndex: 9999,
        maxWidth: "90%", textAlign: "center", boxShadow: `0 4px 20px ${(colors[type] || C.cyan)}30`,
      }}, msg);
    }

    // --- NavBar ---
    function NavBar() {
      const { screen, setScreen, wo } = useContext(AppCtx);
      const items = [
        { id: "home", icon: "âš¡", label: "Home" }, { id: "blueprints", icon: "ðŸ“‹", label: "Plans" },
        { id: "history", icon: "ðŸ“Š", label: "History" }, { id: "analytics", icon: "ðŸ“ˆ", label: "Stats" },
        { id: "settings", icon: "âš™ï¸", label: "Settings" },
      ];
      // Insert training tab when workout is active
      if (wo) items.splice(0, 0, { id: "train", icon: "ðŸ”¥", label: "Workout", active: true });
      return h("div", { style: {
        position: "fixed", bottom: 0, left: "50%", transform: "translateX(-50%)", width: "100%", maxWidth: 500,
        background: `${C.surface}f0`, borderTop: `1px solid ${C.border}`, display: "flex",
        padding: "6px 0 env(safe-area-inset-bottom, 8px)", backdropFilter: "blur(20px)", zIndex: 100,
      }}, items.map(it => h("button", { key: it.id, onClick: () => setScreen(it.id), style: {
        flex: 1, background: "none", border: "none", color: screen === it.id ? (it.active ? C.green : C.cyan) : (it.active ? C.amber : C.textDim),
        display: "flex", flexDirection: "column", alignItems: "center", gap: 2, padding: "6px 0", cursor: "pointer",
        position: "relative",
      }}, h("span", { style: { fontSize: 18 } }, it.icon), h("span", { style: { fontSize: 10, fontWeight: screen === it.id ? 600 : 400 } }, it.label),
        it.active && screen !== "train" && h("div", { style: { position: "absolute", top: 2, right: "15%", width: 7, height: 7, borderRadius: "50%", background: C.green, boxShadow: `0 0 6px ${C.green}` } }),
      )));
    }

    // ============================================================
    // HOME
    // ============================================================
    function Home() {
      const { db, setScreen, setWo, notify } = useContext(AppCtx);
      const [quickText, setQuickText] = useState("");
      const [showQuick, setShowQuick] = useState(false);
      const [viewMode, setViewMode] = useState("week"); // "week" or "month"

      const todayIdx = new Date().getDay();
      const todayName = DAYS[todayIdx === 0 ? 6 : todayIdx - 1];
      const todayBP = db.blueprints?.[todayName];

      const mondayStart = thisMonday();
      const monthStart = thisMonthStart();
      const cutoff = viewMode === "week" ? mondayStart : monthStart;

      const filteredHistory = db.history.filter(x => new Date(x.date) >= cutoff);
      const totalVol = filteredHistory.reduce((s, x) => s + (x.exercises || []).reduce((es, ex) => es + (ex.sets || []).reduce((ss, st) => ss + (st.weight || 0) * (st.reps || 0), 0), 0), 0);

      // Sets per muscle group for selected period
      const muscleSets = useMemo(() => {
        const counts = {};
        filteredHistory.forEach(session => {
          (session.exercises || []).forEach(ex => {
            const muscle = ex.muscle || detectMuscle(ex.name);
            if (muscle && muscle !== "other" && muscle !== "cardio") {
              counts[muscle] = (counts[muscle] || 0) + (ex.sets || []).filter(s => s.completed !== false).length;
            }
          });
        });
        return Object.entries(counts).sort((a, b) => b[1] - a[1]);
      }, [filteredHistory]);

      function makeExercises(names) {
        return names.map(name => ({
          id: genId(), name, muscle: detectMuscle(name), isCardio: isCardio(name),
          sets: isCardio(name) ? [{ id: genId(), duration: 0, completed: false }]
            : Array.from({ length: SETS_PER_EXERCISE }, () => ({ id: genId(), weight: 0, reps: 0, completed: false })),
        }));
      }

      function startBP(bp) { setWo({ id: genId(), exercises: makeExercises(bp.exercises.map(e => e.name)), currentExIdx: 0, currentSetIdx: 0, startTime: Date.now() }); setScreen("train"); }
      function startQuick() { if (!quickText.trim()) return; const lines = quickText.split("\n").map(l => l.trim()).filter(Boolean); setWo({ id: genId(), exercises: makeExercises(lines), currentExIdx: 0, currentSetIdx: 0, startTime: Date.now() }); setScreen("train"); notify(`Loaded ${lines.length} exercises`, "success"); }
      function startEmpty() { setWo({ id: genId(), exercises: [], currentExIdx: 0, currentSetIdx: 0, startTime: Date.now() }); setScreen("train"); }

      return h("div", { className: "fade-in", style: { padding: "20px 16px", maxWidth: 500, margin: "0 auto", paddingBottom: 90 } },
        // Header
        h("div", { style: { textAlign: "center", padding: "30px 0 20px" } },
          h("h1", { style: { fontSize: 36, fontWeight: 900, letterSpacing: -1, background: `linear-gradient(135deg, ${C.cyan}, ${C.green})`, WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent" } }, "REPVAULT"),
          h("p", { style: { color: C.textDim, fontSize: 13, marginTop: 4, fontWeight: 300 } }, "Your Training. Locked In."),
        ),
        // Week / Month toggle
        h("div", { style: { display: "flex", gap: 4, marginBottom: 12, background: C.surface, borderRadius: 10, padding: 3 } },
          h("button", { onClick: () => setViewMode("week"), style: { flex: 1, padding: "8px 0", borderRadius: 8, border: "none", fontSize: 12, fontWeight: 600, cursor: "pointer", background: viewMode === "week" ? C.cyan : "transparent", color: viewMode === "week" ? C.bg : C.textDim } }, "This Week"),
          h("button", { onClick: () => setViewMode("month"), style: { flex: 1, padding: "8px 0", borderRadius: 8, border: "none", fontSize: 12, fontWeight: 600, cursor: "pointer", background: viewMode === "month" ? C.cyan : "transparent", color: viewMode === "month" ? C.bg : C.textDim } }, "This Month"),
        ),
        // Summary
        h("div", { style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}`, marginBottom: 16 } },
          h("div", { style: { fontSize: 11, color: C.textDim, textTransform: "uppercase", letterSpacing: 1, marginBottom: 12 } }, viewMode === "week" ? "This Week (Monâ€“Sun)" : "Month to Date"),
          h("div", { style: { display: "flex", gap: 16 } },
            h("div", { style: { flex: 1, textAlign: "center" } }, h("div", { style: { fontSize: 28, fontWeight: 700, color: C.cyan, fontFamily: "'JetBrains Mono'" } }, filteredHistory.length), h("div", { style: { fontSize: 11, color: C.textDim } }, "Sessions")),
            h("div", { style: { width: 1, background: C.border } }),
            h("div", { style: { flex: 1, textAlign: "center" } }, h("div", { style: { fontSize: 28, fontWeight: 700, color: C.green, fontFamily: "'JetBrains Mono'" } }, muscleSets.reduce((s, [, c]) => s + c, 0)), h("div", { style: { fontSize: 11, color: C.textDim } }, "Working Sets")),
            h("div", { style: { width: 1, background: C.border } }),
            h("div", { style: { flex: 1, textAlign: "center" } }, h("div", { style: { fontSize: 28, fontWeight: 700, color: C.amber, fontFamily: "'JetBrains Mono'" } }, Object.keys(db.pbs || {}).length), h("div", { style: { fontSize: 11, color: C.textDim } }, "PBs")),
          ),
        ),
        // Muscle group breakdown
        muscleSets.length > 0 && h("div", { style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}`, marginBottom: 16 } },
          h("div", { style: { fontSize: 11, color: C.textDim, textTransform: "uppercase", letterSpacing: 1, marginBottom: 12 } }, `${viewMode === "week" ? "Weekly" : "Monthly"} Sets by Muscle`),
          h("div", { style: { display: "flex", flexWrap: "wrap", gap: 6 } },
            muscleSets.map(([muscle, count]) => {
              const maxSets = muscleSets[0]?.[1] || 1;
              const intensity = Math.max(0.3, count / maxSets);
              const muscleColors = { chest: C.cyan, back: C.green, shoulders: C.amber, glutes: C.purple, quads: C.cyan, hamstrings: C.green, calves: C.amber, biceps: C.cyan, triceps: C.green, core: C.amber };
              const mc = muscleColors[muscle] || C.cyan;
              return h("div", { key: muscle, style: { display: "flex", alignItems: "center", gap: 8, padding: "8px 12px", background: `${mc}${Math.round(intensity * 20).toString(16).padStart(2, "0")}`, border: `1px solid ${mc}30`, borderRadius: 10, minWidth: "calc(50% - 3px)" } },
                h("div", { style: { flex: 1 } },
                  h("div", { style: { fontSize: 12, fontWeight: 600, color: C.text, textTransform: "capitalize" } }, muscle),
                ),
                h("div", { style: { fontSize: 20, fontWeight: 700, color: mc, fontFamily: "'JetBrains Mono'" } }, count),
              );
            }),
          ),
        ),
        // Today's blueprint
        todayBP && h("button", { onClick: () => startBP(todayBP), style: { width: "100%", background: `linear-gradient(135deg, ${C.cyan}15, ${C.green}15)`, border: `1px solid ${C.cyan}40`, borderRadius: 16, padding: 20, color: C.text, cursor: "pointer", textAlign: "left", marginBottom: 16 } },
          h("div", { style: { fontSize: 11, color: C.cyan, textTransform: "uppercase", letterSpacing: 1, marginBottom: 6 } }, `${todayName}'s Plan`),
          h("div", { style: { fontSize: 18, fontWeight: 700, marginBottom: 8 } }, todayBP.name || `${todayName} Session`),
          h("div", { style: { fontSize: 12, color: C.textDim } }, `${todayBP.exercises?.length || 0} exercises â€¢ Tap to start`),
        ),
        // Quick start buttons
        h("div", { style: { display: "flex", gap: 10, marginBottom: 16 } },
          h("button", { onClick: () => setShowQuick(!showQuick), style: { flex: 1, background: C.surface, border: `1px solid ${C.border}`, borderRadius: 12, padding: "16px 12px", color: C.text, cursor: "pointer", fontSize: 14, fontWeight: 600 } }, "ðŸ“ Bulk Import"),
          h("button", { onClick: startEmpty, style: { flex: 1, background: C.surface, border: `1px solid ${C.border}`, borderRadius: 12, padding: "16px 12px", color: C.text, cursor: "pointer", fontSize: 14, fontWeight: 600 } }, "âž• Empty Session"),
        ),
        // Bulk import
        showQuick && h("div", { className: "slide-up", style: { background: C.surface, borderRadius: 16, padding: 16, border: `1px solid ${C.border}`, marginBottom: 16 } },
          h("div", { style: { fontSize: 12, color: C.textDim, marginBottom: 8 } }, "One exercise per line:"),
          h("textarea", { value: quickText, onChange: e => setQuickText(e.target.value), placeholder: "Bench Press\nLat Pulldown\nSquat\nBicep Curl", rows: 6, style: { width: "100%", background: C.bg, border: `1px solid ${C.border}`, borderRadius: 8, padding: 12, color: C.text, fontSize: 14, resize: "none", outline: "none" } }),
          h("button", { onClick: startQuick, style: { width: "100%", marginTop: 10, background: C.cyan, color: C.bg, border: "none", borderRadius: 10, padding: 14, fontSize: 15, fontWeight: 700, cursor: "pointer" } }, "Load & Start"),
        ),
        // Export
        h("button", { onClick: () => setScreen("export"), style: { width: "100%", background: C.surface, border: `1px solid ${C.border}`, borderRadius: 12, padding: 14, color: C.textDim, cursor: "pointer", fontSize: 13, fontWeight: 500 } }, "ðŸ“¤ Export AI-Ready Data"),
      );
    }

    // ============================================================
    // TRAINING SCREEN
    // ============================================================
    function Train() {
      const { db, persist, notify, setScreen, wo, setWo, phase, setPhase, timer, setTimer, paused, setPaused, clock, setClock } = useContext(AppCtx);
      const [showAdd, setShowAdd] = useState(false);
      const [addText, setAddText] = useState("");
      const [showQuit, setShowQuit] = useState(false);
      const [editingQueueIdx, setEditingQueueIdx] = useState(null);
      const [editingQueueName, setEditingQueueName] = useState("");

      const timerRef = useRef(null);
      const clockRef = useRef(null);
      const backRef = useRef(0);
      const timers = db.settings?.timers || DEFAULT_TIMERS;
      const curEx = wo?.exercises[wo.currentExIdx];
      const totalSets = wo ? wo.exercises.reduce((s, e) => s + e.sets.length, 0) : 0;
      const doneSets = wo ? wo.exercises.reduce((s, e) => s + e.sets.filter(x => x.completed).length, 0) : 0;
      const remainingSets = totalSets - doneSets;

      // Estimated time remaining
      const estRemaining = useMemo(() => {
        if (!wo || phase === PHASES.DONE) return 0;
        const avgSetCycle = timers.work + timers.restSet;
        const remainingExercises = wo.exercises.length - wo.currentExIdx - 1;
        return Math.max(0, remainingSets * avgSetCycle + remainingExercises * (timers.restEx - timers.restSet));
      }, [wo?.currentExIdx, wo?.currentSetIdx, remainingSets, timers, phase]);

      // Determine which exercise to show stats for: current, or next during REST_EX
      const statsEx = (phase === PHASES.REST_EX && wo) ? wo.exercises[wo.currentExIdx + 1] : curEx;

      // PB data
      const curPB = statsEx ? db.pbs?.[pbKey(statsEx.name)] : null;

      // Find the session where the PB weight was set
      const pbSession = useMemo(() => {
        if (!statsEx || !curPB) return null;
        const nm = pbKey(statsEx.name);
        for (let i = db.history.length - 1; i >= 0; i--) {
          const ex = db.history[i].exercises?.find(e => pbKey(e.name) === nm);
          if (ex && ex.sets?.some(s => s.weight === curPB.maxWeight)) return { date: db.history[i].date };
        }
        return null;
      }, [statsEx?.name, curPB, db.history]);

      // Last performance â€” most recent session with this exercise
      const lastPerf = useMemo(() => {
        if (!statsEx) return null;
        const nm = pbKey(statsEx.name);
        for (let i = db.history.length - 1; i >= 0; i--) {
          const ex = db.history[i].exercises?.find(e => pbKey(e.name) === nm);
          if (ex) {
            const sets = ex.sets || [];
            const maxW = Math.max(0, ...sets.map(s => s.weight || 0));
            return {
              date: db.history[i].date,
              sets,
              maxWeight: maxW,
              vol: sets.reduce((s, st) => s + (st.weight || 0) * (st.reps || 0), 0),
            };
          }
        }
        return null;
      }, [statsEx?.name, db.history]);

      // Auto-populate weights (not reps) from last session when exercise changes
      const prevExIdxRef = useRef(null);
      useEffect(() => {
        if (!wo || !curEx || curEx.isCardio) return;
        if (prevExIdxRef.current === wo.currentExIdx) return;
        prevExIdxRef.current = wo.currentExIdx;
        if (lastPerf && lastPerf.sets.length > 0) {
          const allEmpty = curEx.sets.every(s => !s.weight || s.weight === 0);
          if (allEmpty) {
            setWo(prev => {
              const next = deepClone(prev);
              const ex = next.exercises[next.currentExIdx];
              ex.sets.forEach((s, i) => {
                const historySet = lastPerf.sets[i] || lastPerf.sets[lastPerf.sets.length - 1];
                if (historySet) {
                  s.weight = historySet.weight || 0;
                  // Don't pre-populate reps â€” user enters fresh each set
                }
              });
              return next;
            });
          }
        }
      }, [wo?.currentExIdx, lastPerf]);

      function updateSet(ei, si, field, val) {
        setWo(prev => {
          const next = deepClone(prev);
          next.exercises[ei].sets[si][field] = val;
          return next;
        });
      }

      function spreadWeight(ei) {
        setWo(prev => {
          const next = deepClone(prev);
          const w = next.exercises[ei].sets[0]?.weight;
          if (!w) return prev;
          for (let i = 1; i < next.exercises[ei].sets.length; i++) {
            if (!next.exercises[ei].sets[i].weight) next.exercises[ei].sets[i].weight = w;
          }
          return next;
        });
      }

      function copyWeightDown(ei, fromSetIdx) {
        setWo(prev => {
          const next = deepClone(prev);
          const w = next.exercises[ei].sets[fromSetIdx]?.weight;
          if (!w) return prev;
          for (let i = fromSetIdx + 1; i < next.exercises[ei].sets.length; i++) {
            next.exercises[ei].sets[i].weight = w;
          }
          return next;
        });
        notify("Weight copied to remaining sets", "success");
      }

      useEffect(() => { audio.init(); audio.startHeartbeat(); return () => audio.stopHeartbeat(); }, []);

      // --- CRASH RECOVERY: auto-save workout state every 3s + on state change ---
      const saveIntervalRef = useRef(null);
      useEffect(() => {
        if (!wo) { clearActiveWorkout(); return; }
        saveActiveWorkout(wo, phase, Math.floor((Date.now() - wo.startTime) / 1000));
        saveIntervalRef.current = setInterval(() => {
          saveActiveWorkout(wo, phase, Math.floor((Date.now() - wo.startTime) / 1000));
        }, 3000);
        return () => clearInterval(saveIntervalRef.current);
      }, [wo, phase]);

      // Wall-clock based timer â€” stores the absolute end time so we can catch up after lock/resume
      const phaseEndTime = useRef(Date.now() + (db.settings?.timers?.prep || DEFAULT_TIMERS.prep) * 1000);

      // Set the end time whenever phase changes
      function setPhaseTimer(seconds) {
        phaseEndTime.current = Date.now() + seconds * 1000;
        setTimer(seconds);
      }

      // Timer tick â€” calculates remaining from wall clock
      useEffect(() => {
        if (paused || phase === PHASES.DONE || !wo) return;
        timerRef.current = setInterval(() => {
          const remaining = (phaseEndTime.current - Date.now()) / 1000;
          if (remaining <= 3.1 && remaining > 2.9) audio.countdownPip();
          if (remaining <= 2.1 && remaining > 1.9) audio.countdownPip();
          if (remaining <= 1.1 && remaining > 0.9) audio.countdownPip();
          if (remaining <= 0) { audio.phasePip(); advancePhase(); return; }
          setTimer(remaining);
        }, 100);
        return () => clearInterval(timerRef.current);
      }, [phase, paused, wo?.currentExIdx, wo?.currentSetIdx, wo]);

      // Resume catch-up: when app becomes visible again, check if timer expired while locked
      useEffect(() => {
        function handleResume() {
          if (document.visibilityState !== "visible" || paused || phase === PHASES.DONE || !wo) return;
          const remaining = (phaseEndTime.current - Date.now()) / 1000;
          if (remaining <= 0) {
            // Phase expired while locked â€” advance
            audio.phasePip();
            advancePhase();
          } else {
            setTimer(remaining);
          }
        }
        document.addEventListener("visibilitychange", handleResume);
        window.addEventListener("focus", handleResume);
        return () => { document.removeEventListener("visibilitychange", handleResume); window.removeEventListener("focus", handleResume); };
      }, [phase, paused, wo?.currentExIdx, wo?.currentSetIdx, wo]);

      // Pause/resume: adjust end time when pausing/unpausing
      const pausedAtRef = useRef(null);
      const remainingAtPause = useRef(0);
      useEffect(() => {
        if (paused) {
          // Store how much time was left
          pausedAtRef.current = Date.now();
          remainingAtPause.current = Math.max(0, (phaseEndTime.current - Date.now()) / 1000);
        } else if (pausedAtRef.current !== null) {
          // Restore end time based on remaining
          phaseEndTime.current = Date.now() + remainingAtPause.current * 1000;
          pausedAtRef.current = null;
        }
      }, [paused]);

      // Session clock
      useEffect(() => {
        if (!wo) return;
        clockRef.current = setInterval(() => setClock(Math.floor((Date.now() - wo.startTime) / 1000)), 1000);
        return () => clearInterval(clockRef.current);
      }, [wo?.startTime]);

      // Media session controls for lock screen
      useEffect(() => {
        if (!("mediaSession" in navigator) || !wo) return;
        try {
          navigator.mediaSession.setActionHandler("play", () => setPaused(false));
          navigator.mediaSession.setActionHandler("pause", () => setPaused(true));
          navigator.mediaSession.setActionHandler("nexttrack", () => { clearInterval(timerRef.current); advancePhase(); });
          navigator.mediaSession.setActionHandler("previoustrack", () => goBack());
        } catch {}
      }, [wo, phase]);

      useEffect(() => { if (curEx && wo) updateMedia(`${curEx.name} - Set ${wo.currentSetIdx + 1}`, `${phase} â€¢ ${fmtTime(timer)}`); }, [phase, timer, curEx?.name, wo?.currentSetIdx]);

      function advancePhase() {
        if (!wo) return;
        const ex = wo.exercises[wo.currentExIdx];
        if (!ex) { finish(); return; }
        if (phase === PHASES.PREP) { setPhase(PHASES.WORK); setPhaseTimer(timers.work); audio.speak(`${ex.name}, Set ${wo.currentSetIdx + 1}, Work`); }
        else if (phase === PHASES.WORK) {
          setWo(prev => { const n = deepClone(prev); if (n.exercises[n.currentExIdx]?.sets[n.currentSetIdx]) n.exercises[n.currentExIdx].sets[n.currentSetIdx].completed = true; return n; });
          const lastSet = wo.currentSetIdx >= ex.sets.length - 1, lastEx = wo.currentExIdx >= wo.exercises.length - 1;
          if (lastSet && lastEx) { setPhase(PHASES.DONE); setTimer(0); audio.speak("Workout Complete"); }
          else if (lastSet) { setPhase(PHASES.REST_EX); setPhaseTimer(timers.restEx); audio.speak("Rest between exercises"); }
          else { setPhase(PHASES.REST_SET); setPhaseTimer(timers.restSet); audio.speak(`Rest. Next: Set ${wo.currentSetIdx + 2}`); }
        }
        else if (phase === PHASES.REST_SET) { setWo(prev => ({ ...prev, currentSetIdx: prev.currentSetIdx + 1 })); setPhase(PHASES.WORK); setPhaseTimer(timers.work); audio.speak(`${ex.name}, Set ${wo.currentSetIdx + 2}, Work`); }
        else if (phase === PHASES.REST_EX) { const ni = wo.currentExIdx + 1; setWo(prev => ({ ...prev, currentExIdx: ni, currentSetIdx: 0 })); setPhase(PHASES.PREP); setPhaseTimer(timers.prep); const ne = wo.exercises[ni]; if (ne) audio.speak(`Next: ${ne.name}`); }
      }

      function skip() { clearInterval(timerRef.current); pausedAtRef.current = null; remainingAtPause.current = 0; setPaused(false); advancePhase(); }

      function goBack() {
        if (!wo) return;
        // Navigate backwards through the phase sequence
        if (phase === PHASES.REST_SET) {
          // Go back to WORK for current set (re-do this set)
          setPhase(PHASES.WORK); setPhaseTimer(timers.work);
          // Un-complete the current set since we're going back to it
          setWo(prev => {
            const next = deepClone(prev);
            if (next.exercises[next.currentExIdx]?.sets[next.currentSetIdx]) next.exercises[next.currentExIdx].sets[next.currentSetIdx].completed = false;
            return next;
          });
        } else if (phase === PHASES.REST_EX) {
          // Go back to WORK for the last set of current exercise
          const ex = wo.exercises[wo.currentExIdx];
          const lastSetIdx = ex.sets.length - 1;
          setWo(prev => {
            const next = deepClone(prev);
            next.currentSetIdx = lastSetIdx;
            if (next.exercises[next.currentExIdx]?.sets[lastSetIdx]) next.exercises[next.currentExIdx].sets[lastSetIdx].completed = false;
            return next;
          });
          setPhase(PHASES.WORK); setPhaseTimer(timers.work);
        } else if (phase === PHASES.WORK) {
          // Go back to REST before this set, or to previous exercise
          if (wo.currentSetIdx > 0) {
            // Go to REST_SET before this set, and move set index back
            setWo(prev => ({ ...prev, currentSetIdx: prev.currentSetIdx - 1 }));
            setPhase(PHASES.REST_SET); setPhaseTimer(timers.restSet);
          } else if (wo.currentExIdx > 0) {
            // Go to REST_EX before this exercise, and move exercise index back
            const pi = wo.currentExIdx - 1;
            setWo(prev => ({ ...prev, currentExIdx: pi, currentSetIdx: prev.exercises[pi].sets.length - 1 }));
            setPhase(PHASES.REST_EX); setPhaseTimer(timers.restEx);
          } else {
            // Very first set of first exercise â€” go to PREP
            setPhase(PHASES.PREP); setPhaseTimer(timers.prep);
          }
        } else if (phase === PHASES.PREP) {
          // Go back to previous exercise's last rest/work if possible
          if (wo.currentExIdx > 0) {
            const pi = wo.currentExIdx - 1;
            setWo(prev => ({ ...prev, currentExIdx: pi, currentSetIdx: prev.exercises[pi].sets.length - 1 }));
            setPhase(PHASES.WORK); setPhaseTimer(timers.work);
          }
          // else: already at the very start, do nothing
        }
      }

      function finish() {
        const session = { id: wo.id, date: new Date().toISOString(), duration: Math.floor((Date.now() - wo.startTime) / 1000), exercises: wo.exercises.map(e => ({ name: e.name, muscle: e.muscle, isCardio: e.isCardio, sets: e.sets.map(s => ({ weight: s.weight || 0, reps: s.reps || 0, duration: s.duration || 0, completed: s.completed })) })) };
        const newPBs = { ...(db.pbs || {}) };
        session.exercises.forEach(ex => { const k = pbKey(ex.name); const b = newPBs[k] || { maxWeight: 0, maxVolume: 0, maxReps: 0 }; ex.sets.forEach(s => { if (s.weight > b.maxWeight) b.maxWeight = s.weight; if (s.reps > b.maxReps) b.maxReps = s.reps; }); const v = ex.sets.reduce((s, st) => s + st.weight * st.reps, 0); if (v > b.maxVolume) b.maxVolume = v; newPBs[k] = b; });
        persist(prev => ({ ...prev, history: [...prev.history, session], pbs: newPBs }));
        clearActiveWorkout();
        notify("Workout saved! ðŸ’ª", "success"); setWo(null); setPhase(PHASES.PREP); setScreen("home");
      }

      function quitWorkout() {
        clearActiveWorkout();
        setWo(null); setPhase(PHASES.PREP); setTimer(DEFAULT_TIMERS.prep); setPaused(false); setClock(0); setShowQuit(false); setScreen("home");
        notify("Workout discarded", "warn");
      }

      // Queue reordering â€” move an exercise to be next
      function moveToNext(exIdx) {
        if (exIdx <= wo.currentExIdx) return; // can't move current or past
        setWo(prev => {
          const next = deepClone(prev);
          const targetPos = prev.currentExIdx + 1;
          if (exIdx === targetPos) return prev; // already next
          const [moved] = next.exercises.splice(exIdx, 1);
          next.exercises.splice(targetPos, 0, moved);
          return next;
        });
        notify("Moved to next", "success");
      }

      function moveUp(exIdx) {
        if (exIdx <= wo.currentExIdx + 1) return; // can't move above current+1
        setWo(prev => {
          const next = deepClone(prev);
          const temp = next.exercises[exIdx];
          next.exercises[exIdx] = next.exercises[exIdx - 1];
          next.exercises[exIdx - 1] = temp;
          return next;
        });
      }

      function moveDown(exIdx) {
        if (exIdx <= wo.currentExIdx || exIdx >= wo.exercises.length - 1) return;
        setWo(prev => {
          const next = deepClone(prev);
          const temp = next.exercises[exIdx];
          next.exercises[exIdx] = next.exercises[exIdx + 1];
          next.exercises[exIdx + 1] = temp;
          return next;
        });
      }

      function removeFromQueue(exIdx) {
        if (exIdx <= wo.currentExIdx) return;
        setWo(prev => {
          const next = deepClone(prev);
          next.exercises.splice(exIdx, 1);
          return next;
        });
        notify("Removed from queue", "info");
      }

      function startEditQueue(exIdx) {
        setEditingQueueIdx(exIdx);
        setEditingQueueName(wo.exercises[exIdx].name);
      }

      function saveEditQueue(exIdx) {
        if (!editingQueueName.trim()) { setEditingQueueIdx(null); return; }
        setWo(prev => {
          const next = deepClone(prev);
          next.exercises[exIdx].name = editingQueueName.trim();
          next.exercises[exIdx].muscle = detectMuscle(editingQueueName.trim());
          next.exercises[exIdx].isCardio = isCardio(editingQueueName.trim());
          return next;
        });
        setEditingQueueIdx(null);
        notify("Exercise updated", "success");
      }

      function jumpToExercise(exIdx) {
        if (exIdx === wo.currentExIdx) return;
        setWo(prev => ({ ...prev, currentExIdx: exIdx, currentSetIdx: 0 }));
        setPhase(PHASES.PREP);
        setPhaseTimer(timers.prep);
        const ex = wo.exercises[exIdx];
        if (ex) audio.speak(`Jumping to ${ex.name}`);
        notify(`Jumped to ${wo.exercises[exIdx]?.name}`, "success");
      }

      function updateExMuscleWo(exIdx, newMuscle) {
        setWo(prev => {
          const next = deepClone(prev);
          next.exercises[exIdx].muscle = newMuscle;
          return next;
        });
      }

      function addExercise(bulk) {
        if (!addText.trim()) return;
        const lines = bulk ? addText.split("\n").map(l => l.trim()).filter(Boolean) : [addText.trim()];
        const newExs = lines.map(name => ({ id: genId(), name, muscle: detectMuscle(name), isCardio: isCardio(name), sets: isCardio(name) ? [{ id: genId(), duration: 0, completed: false }] : Array.from({ length: SETS_PER_EXERCISE }, () => ({ id: genId(), weight: 0, reps: 0, completed: false })) }));
        setWo(prev => ({ ...prev, exercises: [...prev.exercises, ...newExs] }));
        setAddText(""); setShowAdd(false); notify(`Added ${newExs.length} exercise(s)`, "success");
      }

      if (!wo) return h("div", { className: "fade-in", style: { padding: "40px 16px", textAlign: "center", maxWidth: 500, margin: "0 auto", paddingBottom: 90 } },
        h("div", { style: { fontSize: 48, marginBottom: 16 } }, "ðŸ‹ï¸"),
        h("h2", { style: { fontSize: 20, fontWeight: 700, marginBottom: 8 } }, "No Active Workout"),
        h("p", { style: { color: C.textDim, fontSize: 13, marginBottom: 24 } }, "Start a workout from the Home screen or load a Blueprint."),
        h("button", { onClick: () => setScreen("home"), style: { background: C.cyan, color: C.bg, border: "none", borderRadius: 12, padding: "14px 32px", fontSize: 15, fontWeight: 700, cursor: "pointer" } }, "Go Home"),
      );

      const glow = phaseColor[phase] || C.cyan;
      const prog = totalSets > 0 ? doneSets / totalSets : 0;
      const timerTotal = phase === PHASES.PREP ? timers.prep : phase === PHASES.WORK ? timers.work : phase === PHASES.REST_SET ? timers.restSet : phase === PHASES.REST_EX ? timers.restEx : 0;

      return h("div", { style: { minHeight: "100vh", background: C.bg, maxWidth: 500, margin: "0 auto", display: "flex", flexDirection: "column" } },
        // === TRAINING UI ===
        phase !== PHASES.DONE && curEx && h(Fragment, null,
          // Status bar
          h("div", { style: { padding: "6px 16px", display: "flex", justifyContent: "space-between", alignItems: "center", borderBottom: `1px solid ${C.border}` } },
            h("button", { onClick: () => setShowQuit(true), style: { background: "none", border: `1px solid ${C.red}40`, borderRadius: 8, padding: "3px 9px", color: C.red, fontSize: 10, fontWeight: 600, cursor: "pointer" } }, "Quit"),
            h("div", { style: { textAlign: "center" } },
              h("span", { style: { fontSize: 10, color: C.textDim, fontFamily: "'JetBrains Mono'" } }, `â± ${fmtDur(clock)}`),
              estRemaining > 0 && h("span", { style: { fontSize: 10, color: C.textDim, fontFamily: "'JetBrains Mono'", marginLeft: 6 } }, `~${fmtDur(estRemaining)} left`),
            ),
            h("span", { style: { fontSize: 10, color: C.textDim } }, `${doneSets}/${totalSets}`),
            h("button", { onClick: () => { audio.toggle(); notify(audio.enabled ? "Audio ON" : "Audio OFF"); }, style: { background: "none", border: "none", color: audio.enabled ? C.cyan : C.textDim, fontSize: 16, cursor: "pointer" } }, audio.enabled ? "ðŸ”Š" : "ðŸ”‡"),
          ),
          // Progress bar
          h("div", { style: { height: 3, background: C.border } }, h("div", { style: { height: "100%", width: `${prog * 100}%`, background: C.green, transition: "width 0.5s" } })),
          // RING TIMER â€” always dominant
          h("div", { style: { display: "flex", flexDirection: "column", alignItems: "center", padding: "16px 0 8px", position: "relative" } },
            h("div", { style: { position: "absolute", inset: 0, background: `radial-gradient(ellipse at 50% 40%, ${glow}08 0%, transparent 60%)`, pointerEvents: "none" } }),
            // Phase label
            h("div", { style: { display: "flex", alignItems: "center", gap: 6, marginBottom: 10, position: "relative", zIndex: 1 } },
              h("div", { style: { width: 6, height: 6, borderRadius: "50%", background: glow, animation: "pulseDot 2s ease infinite" } }),
              h("span", { style: { fontSize: 10, fontWeight: 600, letterSpacing: 2, textTransform: "uppercase", color: glow } }, phaseLabel[phase] || phase.replace("_", " ")),
            ),
            // Ring
            h("div", { style: { position: "relative", width: 170, height: 170, zIndex: 1 } },
              h(RingTimer, { seconds: timer, total: timerTotal, color: glow, size: 170 }),
              h("div", { style: { position: "absolute", inset: 0, display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center" } },
                h("div", { style: { fontSize: 46, fontWeight: 700, color: C.text, fontFamily: "'JetBrains Mono'", lineHeight: 1, letterSpacing: -2, animation: timer <= 3 && timer > 0 ? "countPulse 0.5s ease infinite" : "none" } }, fmtTime(timer)),
                h("div", { style: { fontSize: 10, color: C.textDim, marginTop: 2 } }, `of ${fmtTime(timerTotal)}`),
              ),
            ),
            // Controls: â® â¸ â­
            h("div", { style: { display: "flex", gap: 14, marginTop: 12, alignItems: "center", position: "relative", zIndex: 1 } },
              h("button", { onClick: goBack, style: { width: 44, height: 44, borderRadius: "50%", background: C.surface, border: `1px solid ${C.border}`, color: C.text, fontSize: 16, cursor: "pointer", display: "flex", alignItems: "center", justifyContent: "center" } }, "â®"),
              h("button", { onClick: () => setPaused(!paused), style: { width: 54, height: 54, borderRadius: "50%", background: paused ? C.green : glow, border: "none", color: C.bg, fontSize: 20, cursor: "pointer", display: "flex", alignItems: "center", justifyContent: "center", boxShadow: `0 0 18px ${paused ? C.greenDim : glow}40` } }, paused ? "â–¶" : "â¸"),
              h("button", { onClick: skip, style: { width: 44, height: 44, borderRadius: "50%", background: C.surface, border: `1px solid ${C.border}`, color: C.text, fontSize: 16, cursor: "pointer", display: "flex", alignItems: "center", justifyContent: "center" } }, "â­"),
            ),
          ),
        ),

        // === SCROLLABLE CONTENT ===
        h("div", { style: { flex: 1, overflowY: "auto", paddingBottom: 90 } },
          // Done screen
          phase === PHASES.DONE && h("div", { style: { textAlign: "center", padding: "40px 16px" } },
            h("div", { style: { fontSize: 48 } }, "ðŸ†"),
            h("h2", { style: { fontSize: 28, fontWeight: 800, color: C.green, marginTop: 12 } }, "Complete!"),
            h("p", { style: { color: C.textDim, marginTop: 4 } }, `${fmtDur(clock)} â€¢ ${doneSets} sets`),
            h("button", { onClick: finish, style: { marginTop: 24, background: C.green, color: C.bg, border: "none", borderRadius: 12, padding: "16px 40px", fontSize: 16, fontWeight: 700, cursor: "pointer" } }, "Save Workout"),
          ),
          // PB & Last Performance display â€” shows for current exercise, or upcoming exercise during REST_EX
          statsEx && phase !== PHASES.DONE && !statsEx.isCardio && (curPB || lastPerf) && h("div", { style: { padding: "4px 16px 0" } },
            // Exercise name + set info
            h("div", { style: { marginBottom: 6 } },
              h("div", { style: { fontSize: 17, fontWeight: 800, letterSpacing: -0.4 } }, phase === PHASES.REST_EX ? (wo.exercises[wo.currentExIdx + 1]?.name || statsEx.name) : statsEx.name),
              h("div", { style: { fontSize: 11, color: C.textDim } }, phase === PHASES.REST_EX ? `Up next â€¢ ${wo.exercises[wo.currentExIdx + 1]?.sets.length || 4} sets` : `Set ${wo.currentSetIdx + 1} of ${curEx.sets.length} â€¢ ${curEx.muscle}`),
            ),
            h("div", { style: { display: "flex", gap: 8, marginBottom: 8 } },
              curPB && h("div", { style: { flex: 1, background: `${C.amber}10`, borderRadius: 10, padding: "10px 12px", border: `1px solid ${C.amber}30` } },
                h("div", { style: { fontSize: 10, color: C.amber, textTransform: "uppercase", letterSpacing: 1, marginBottom: 4 } }, "ðŸ† All-Time PB"),
                h("div", { style: { fontSize: 18, color: C.text, fontFamily: "'JetBrains Mono'", fontWeight: 700 } }, `${curPB.maxWeight}kg`),
                pbSession && h("div", { style: { fontSize: 11, color: C.textDim, marginTop: 2 } }, new Date(pbSession.date).toLocaleDateString("en-GB", { day: "numeric", month: "short" })),
                h("div", { style: { fontSize: 10, color: C.textDim, marginTop: 1 } }, `${curPB.maxReps} reps â€¢ ${curPB.maxVolume}kg vol`),
              ),
              lastPerf && h("div", { style: { flex: 1, background: `${C.cyan}10`, borderRadius: 10, padding: "10px 12px", border: `1px solid ${C.cyan}30` } },
                h("div", { style: { fontSize: 10, color: C.cyan, textTransform: "uppercase", letterSpacing: 1, marginBottom: 4 } }, "ðŸ“… Last Session"),
                h("div", { style: { fontSize: 18, color: C.text, fontFamily: "'JetBrains Mono'", fontWeight: 700 } }, `${lastPerf.maxWeight}kg`),
                h("div", { style: { fontSize: 11, color: C.textDim, marginTop: 2 } }, new Date(lastPerf.date).toLocaleDateString("en-GB", { day: "numeric", month: "short" })),
                h("div", { style: { fontSize: 10, color: C.textDim, marginTop: 1 } }, lastPerf.sets.map((s, i) => `${s.weight}Ã—${s.reps}`).join(" Â· ")),
              ),
            ),
          ),
          // Set inputs
          curEx && phase !== PHASES.DONE && !curEx.isCardio && h("div", { style: { padding: "4px 16px" } },
            // Show exercise name if no PB/Last section rendered it
            !(statsEx && !statsEx.isCardio && (curPB || lastPerf)) && h("div", { style: { marginBottom: 6 } },
              h("div", { style: { fontSize: 17, fontWeight: 800, letterSpacing: -0.4 } }, curEx.name),
              h("div", { style: { fontSize: 11, color: C.textDim } }, `Set ${wo.currentSetIdx + 1} of ${curEx.sets.length} â€¢ ${curEx.muscle}`),
            ),
            h("div", { style: { background: C.surface, borderRadius: 16, padding: 16, border: `1px solid ${C.border}` } },
              h("div", { style: { display: "flex", flexDirection: "column", gap: 8 } },
                curEx.sets.map((s, si) => h("div", { key: si, style: { display: "flex", gap: 8, alignItems: "center", padding: "8px 10px", borderRadius: 10, background: si === wo.currentSetIdx ? `${glow}10` : "transparent", border: si === wo.currentSetIdx ? `1px solid ${glow}30` : "1px solid transparent", opacity: s.completed ? 0.5 : 1 } },
                  h("div", { style: { width: 28, height: 28, borderRadius: "50%", display: "flex", alignItems: "center", justifyContent: "center", fontSize: 12, fontWeight: 700, fontFamily: "'JetBrains Mono'", background: s.completed ? C.green : C.bg, color: s.completed ? C.bg : C.textDim, border: `1px solid ${s.completed ? C.green : C.border}` } }, s.completed ? "âœ“" : si + 1),
                  h("div", { style: { flex: 1, display: "flex", gap: 8 } },
                    h("input", { type: "number", inputMode: "decimal", value: s.weight || "", onChange: e => updateSet(wo.currentExIdx, si, "weight", parseFloat(e.target.value) || 0), onBlur: si === 0 ? () => spreadWeight(wo.currentExIdx) : undefined, placeholder: "KG", style: { width: "100%", background: C.bg, border: `1px solid ${C.cyanDim}`, borderRadius: 8, padding: "10px 8px", color: C.cyan, fontSize: 16, fontFamily: "'JetBrains Mono'", textAlign: "center", outline: "none" } }),
                    h("input", { type: "number", inputMode: "numeric", value: s.reps || "", onChange: e => updateSet(wo.currentExIdx, si, "reps", parseInt(e.target.value) || 0), placeholder: "Reps", style: { width: "100%", background: C.bg, border: `1px solid ${C.greenDim}`, borderRadius: 8, padding: "10px 8px", color: C.green, fontSize: 16, fontFamily: "'JetBrains Mono'", textAlign: "center", outline: "none" } }),
                  ),
                  si < curEx.sets.length - 1 && s.weight ? h("button", { onClick: () => copyWeightDown(wo.currentExIdx, si), title: "Copy weight to remaining sets", style: { background: `${C.cyan}15`, border: `1px solid ${C.cyan}30`, borderRadius: 6, padding: "4px 6px", color: C.cyan, fontSize: 10, fontWeight: 700, cursor: "pointer", flexShrink: 0, whiteSpace: "nowrap" } }, "Copy â†“") : null,
                )),
              ),
            ),
          ),
          // Cardio input
          curEx?.isCardio && phase !== PHASES.DONE && h("div", { style: { padding: "12px 16px" } },
            h("div", { style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}`, textAlign: "center" } },
              h("div", { style: { fontSize: 13, color: C.textDim, marginBottom: 8 } }, "Duration (minutes)"),
              h("input", { type: "number", inputMode: "numeric", value: curEx.sets[0]?.duration || "", onChange: e => updateSet(wo.currentExIdx, 0, "duration", parseInt(e.target.value) || 0), placeholder: "30", style: { width: 120, background: C.bg, border: `1px solid ${C.amberDim}`, borderRadius: 12, padding: 14, color: C.amber, fontSize: 28, fontFamily: "'JetBrains Mono'", textAlign: "center", outline: "none" } }),
            ),
          ),
          // Full exercise list with jump-to
          h("div", { style: { padding: "8px 16px" } },
            h("div", { style: { fontSize: 11, color: C.textDim, textTransform: "uppercase", letterSpacing: 1, marginBottom: 8, paddingLeft: 4 } }, `Exercises (${wo.currentExIdx + 1}/${wo.exercises.length})`),
            // Completed exercises
            wo.exercises.map((ex, i) => {
              if (i > wo.currentExIdx) return null;
              const isCurrent = i === wo.currentExIdx;
              return h("div", { key: ex.id, style: { padding: "8px 12px", borderRadius: 10, background: isCurrent ? `${C.green}10` : `${C.surface}80`, border: `1px solid ${isCurrent ? C.green + "40" : C.border}50`, fontSize: 13, display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 4, opacity: isCurrent ? 1 : 0.6 } },
                h("div", { style: { flex: 1, minWidth: 0 } },
                  h("span", { style: { color: isCurrent ? C.green : C.textDim, fontWeight: isCurrent ? 600 : 400 } }, isCurrent ? "â— " : "âœ“ ", ex.name),
                  isCurrent && h("span", { style: { fontSize: 10, marginLeft: 6, color: C.green } }, "CURRENT"),
                ),
                h("div", { style: { display: "flex", gap: 4, alignItems: "center", flexShrink: 0 } },
                  h("select", { value: ex.muscle, onChange: e => updateExMuscleWo(i, e.target.value), style: { background: C.bg, border: `1px solid ${C.border}`, borderRadius: 6, padding: "3px 6px", color: C.cyan, fontSize: 10, outline: "none", cursor: "pointer", fontFamily: "'JetBrains Mono'" } },
                    MUSCLE_GROUPS.map(m => h("option", { key: m, value: m }, m)),
                    h("option", { value: "other" }, "other"),
                  ),
                  !isCurrent && h("button", { onClick: () => jumpToExercise(i), style: { background: `${C.amber}15`, border: `1px solid ${C.amber}30`, borderRadius: 6, padding: "4px 10px", color: C.amber, fontSize: 10, fontWeight: 700, cursor: "pointer" } }, "GO"),
                ),
              );
            }),
            // Divider
            wo.currentExIdx < wo.exercises.length - 1 && h("div", { style: { fontSize: 10, color: C.textDim, textTransform: "uppercase", letterSpacing: 1, padding: "8px 4px 4px", opacity: 0.5 } }, `Queue (${wo.exercises.length - wo.currentExIdx - 1} remaining)`),
            // Upcoming exercises
            wo.exercises.map((ex, i) => {
              if (i <= wo.currentExIdx) return null;
              const isNext = i === wo.currentExIdx + 1;
              const isEditing = editingQueueIdx === i;
              return h("div", { key: ex.id, style: { padding: "10px 12px", borderRadius: 10, background: isEditing ? C.surfaceLight : C.surface, border: `1px solid ${isNext ? C.cyan + "40" : isEditing ? C.amber + "40" : C.border}`, fontSize: 13, color: C.textDim, display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 4 } },
                h("div", { style: { flex: 1, minWidth: 0, marginRight: 8 } },
                  isEditing
                    ? h("div", { style: { display: "flex", gap: 4, alignItems: "center" } },
                        h("input", { type: "text", value: editingQueueName, onChange: e => setEditingQueueName(e.target.value), onKeyDown: e => { if (e.key === "Enter") saveEditQueue(i); if (e.key === "Escape") setEditingQueueIdx(null); }, autoFocus: true, style: { flex: 1, background: C.bg, border: `1px solid ${C.amber}40`, borderRadius: 6, padding: "6px 8px", color: C.text, fontSize: 13, outline: "none" } }),
                        h("button", { onClick: () => saveEditQueue(i), style: { background: C.amber, color: C.bg, border: "none", borderRadius: 6, padding: "6px 8px", fontSize: 10, fontWeight: 700, cursor: "pointer", flexShrink: 0 } }, "âœ“"),
                      )
                    : h("div", { onClick: () => startEditQueue(i), style: { cursor: "pointer" } },
                        h("span", { style: { color: isNext ? C.cyan : C.textDim, fontWeight: isNext ? 600 : 400 } }, isNext ? "â–¶ " : "", ex.name),
                        h("span", { style: { fontSize: 11, marginLeft: 6 } }, ex.isCardio ? "cardio" : `${ex.sets.length}s`),
                        h("span", { style: { fontSize: 9, marginLeft: 6, color: C.textDim, opacity: 0.5 } }, "âœï¸"),
                      ),
                ),
                !isEditing && h("div", { style: { display: "flex", gap: 2, flexShrink: 0, alignItems: "center" } },
                  h("select", { value: ex.muscle, onChange: e => updateExMuscleWo(i, e.target.value), onClick: e => e.stopPropagation(), style: { background: C.bg, border: `1px solid ${C.border}`, borderRadius: 6, padding: "3px 6px", color: C.cyan, fontSize: 10, outline: "none", cursor: "pointer", fontFamily: "'JetBrains Mono'" } },
                    MUSCLE_GROUPS.map(m => h("option", { key: m, value: m }, m)),
                    h("option", { value: "other" }, "other"),
                  ),
                  h("button", { onClick: () => jumpToExercise(i), title: "Jump to", style: { background: `${C.green}15`, border: `1px solid ${C.green}30`, borderRadius: 6, padding: "4px 8px", color: C.green, fontSize: 10, fontWeight: 700, cursor: "pointer" } }, "GO"),
                  h("button", { onClick: () => moveUp(i), title: "Move up", style: { background: "none", border: `1px solid ${C.border}`, borderRadius: 6, padding: "4px 6px", color: C.textDim, fontSize: 12, cursor: "pointer", opacity: i <= wo.currentExIdx + 1 ? 0.3 : 1 } }, "â†‘"),
                  h("button", { onClick: () => moveDown(i), title: "Move down", style: { background: "none", border: `1px solid ${C.border}`, borderRadius: 6, padding: "4px 6px", color: C.textDim, fontSize: 12, cursor: "pointer", opacity: i >= wo.exercises.length - 1 ? 0.3 : 1 } }, "â†“"),
                  h("button", { onClick: () => removeFromQueue(i), title: "Remove", style: { background: "none", border: `1px solid ${C.red}30`, borderRadius: 6, padding: "4px 6px", color: C.red, fontSize: 11, cursor: "pointer" } }, "âœ•"),
                ),
              );
            }),
          ),
          // Add exercise
          h("div", { style: { padding: "8px 16px" } },
            h("button", { onClick: () => setShowAdd(true), style: { width: "100%", background: "none", border: `1px dashed ${C.border}`, borderRadius: 10, padding: 12, color: C.textDim, cursor: "pointer", fontSize: 13 } }, "+ Add Exercise"),
          ),
        ),
        // Add modal
        showAdd && h("div", { style: { position: "fixed", inset: 0, background: "rgba(0,0,0,0.7)", zIndex: 200, display: "flex", alignItems: "center", justifyContent: "center", padding: 20 }, onClick: e => { if (e.target === e.currentTarget) setShowAdd(false); } },
          h("div", { className: "slide-up", style: { background: C.surface, borderRadius: 20, padding: 24, width: "100%", maxWidth: 400, border: `1px solid ${C.border}` } },
            h("h3", { style: { fontSize: 16, fontWeight: 700, marginBottom: 12 } }, "Add Exercises"),
            h("textarea", { value: addText, onChange: e => setAddText(e.target.value), placeholder: "Exercise name\n(one per line for bulk)", rows: 4, autoFocus: true, style: { width: "100%", background: C.bg, border: `1px solid ${C.border}`, borderRadius: 8, padding: 12, color: C.text, fontSize: 14, resize: "none", outline: "none" } }),
            h("div", { style: { display: "flex", gap: 8, marginTop: 12 } },
              h("button", { onClick: () => addExercise(false), style: { flex: 1, background: C.cyan, color: C.bg, border: "none", borderRadius: 10, padding: 12, fontWeight: 700, cursor: "pointer" } }, "Single"),
              h("button", { onClick: () => addExercise(true), style: { flex: 1, background: C.green, color: C.bg, border: "none", borderRadius: 10, padding: 12, fontWeight: 700, cursor: "pointer" } }, "Bulk"),
            ),
          ),
        ),
        // Quit confirmation modal
        showQuit && h("div", { style: { position: "fixed", inset: 0, background: "rgba(0,0,0,0.7)", zIndex: 200, display: "flex", alignItems: "center", justifyContent: "center", padding: 20 }, onClick: e => { if (e.target === e.currentTarget) setShowQuit(false); } },
          h("div", { className: "slide-up", style: { background: C.surface, borderRadius: 20, padding: 24, width: "100%", maxWidth: 360, border: `1px solid ${C.border}`, textAlign: "center" } },
            h("div", { style: { fontSize: 36, marginBottom: 12 } }, "âš ï¸"),
            h("h3", { style: { fontSize: 18, fontWeight: 700, marginBottom: 8 } }, "Quit Workout?"),
            h("p", { style: { color: C.textDim, fontSize: 13, marginBottom: 20 } }, "This will discard all progress. Save first if you want to keep it."),
            h("div", { style: { display: "flex", gap: 8 } },
              h("button", { onClick: finish, style: { flex: 1, background: C.green, color: C.bg, border: "none", borderRadius: 10, padding: 14, fontWeight: 700, cursor: "pointer" } }, "Save & End"),
              h("button", { onClick: quitWorkout, style: { flex: 1, background: C.red, color: "#fff", border: "none", borderRadius: 10, padding: 14, fontWeight: 700, cursor: "pointer" } }, "Discard"),
              h("button", { onClick: () => setShowQuit(false), style: { flex: 1, background: C.bg, color: C.textDim, border: `1px solid ${C.border}`, borderRadius: 10, padding: 14, fontWeight: 600, cursor: "pointer" } }, "Cancel"),
            ),
          ),
        ),
      );
    }

    // ============================================================
    // BLUEPRINTS
    // ============================================================
    function Blueprints() {
      const { db, persist, notify, setWo, setScreen } = useContext(AppCtx);
      const [day, setDay] = useState(DAYS[0]);
      const [editName, setEditName] = useState("");
      const [editExs, setEditExs] = useState("");
      const [editing, setEditing] = useState(false);
      const bp = db.blueprints?.[day];

      function startEdit() { setEditName(bp?.name || `${day} Session`); setEditExs(bp?.exercises?.map(e => e.name).join("\n") || ""); setEditing(true); }
      function updateExMuscle(idx, newMuscle) {
        persist(prev => {
          const bps = { ...prev.blueprints };
          const current = bps[day];
          if (!current) return prev;
          const exs = [...current.exercises];
          exs[idx] = { ...exs[idx], muscle: newMuscle };
          bps[day] = { ...current, exercises: exs };
          return { ...prev, blueprints: bps };
        });
        notify("Muscle group updated", "success");
      }
      function save() {
        const lines = editExs.split("\n").map(l => l.trim()).filter(Boolean);
        const exs = lines.map(name => ({ name, muscle: detectMuscle(name), isCardio: isCardio(name), duration: isCardio(name) ? 30 : undefined }));
        persist(prev => ({ ...prev, blueprints: { ...prev.blueprints, [day]: { name: editName, exercises: exs } } }));
        setEditing(false); notify("Blueprint saved", "success");
      }
      function load() {
        if (!bp?.exercises?.length) return;
        const exs = bp.exercises.map(e => ({ id: genId(), name: e.name, muscle: e.muscle || detectMuscle(e.name), isCardio: isCardio(e.name), sets: isCardio(e.name) ? [{ id: genId(), duration: e.duration || 0, completed: false }] : Array.from({ length: SETS_PER_EXERCISE }, () => ({ id: genId(), weight: 0, reps: 0, completed: false })) }));
        setWo({ id: genId(), exercises: exs, currentExIdx: 0, currentSetIdx: 0, startTime: Date.now() }); setScreen("train"); notify("Blueprint loaded!", "success");
      }

      return h("div", { className: "fade-in", style: { padding: "20px 16px", maxWidth: 500, margin: "0 auto", paddingBottom: 90 } },
        h("h2", { style: { fontSize: 22, fontWeight: 800, marginBottom: 16 } }, "Weekly Blueprint"),
        h("div", { style: { display: "flex", gap: 4, overflowX: "auto", marginBottom: 16, paddingBottom: 4 } },
          DAYS.map(d => h("button", { key: d, onClick: () => { setDay(d); setEditing(false); }, style: { padding: "8px 14px", borderRadius: 10, fontSize: 12, fontWeight: 600, whiteSpace: "nowrap", cursor: "pointer", border: "none", background: day === d ? C.cyan : C.surface, color: day === d ? C.bg : C.textDim } }, d.slice(0, 3))),
        ),
        !editing ? h("div", { style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}` } },
          h("div", { style: { fontSize: 16, fontWeight: 700, marginBottom: 12 } }, bp?.name || `${day} â€” No plan`),
          bp?.exercises?.length > 0 ? h(Fragment, null,
            h("div", { style: { display: "flex", flexDirection: "column", gap: 6, marginBottom: 16 } },
              bp.exercises.map((ex, i) => h("div", { key: i, style: { display: "flex", justifyContent: "space-between", alignItems: "center", padding: "8px 12px", background: C.bg, borderRadius: 8, fontSize: 13 } },
                h("span", { style: { flex: 1 } }, ex.name),
                h("select", { value: ex.muscle || detectMuscle(ex.name), onChange: e => updateExMuscle(i, e.target.value), style: { background: C.surface, border: `1px solid ${C.border}`, borderRadius: 6, padding: "4px 8px", color: C.cyan, fontSize: 11, outline: "none", cursor: "pointer", fontFamily: "'JetBrains Mono'", textTransform: "capitalize" } },
                  MUSCLE_GROUPS.map(m => h("option", { key: m, value: m }, m)),
                  h("option", { value: "other" }, "other"),
                ),
              )),
            ),
            h("div", { style: { display: "flex", gap: 8 } },
              h("button", { onClick: load, style: { flex: 1, background: C.cyan, color: C.bg, border: "none", borderRadius: 10, padding: 14, fontWeight: 700, cursor: "pointer" } }, "Load & Start"),
              h("button", { onClick: startEdit, style: { flex: 1, background: C.bg, color: C.text, border: `1px solid ${C.border}`, borderRadius: 10, padding: 14, fontWeight: 600, cursor: "pointer" } }, "Edit"),
            ),
          ) : h("button", { onClick: startEdit, style: { width: "100%", background: `${C.cyan}15`, border: `1px dashed ${C.cyan}40`, borderRadius: 10, padding: 16, color: C.cyan, cursor: "pointer", fontSize: 14, fontWeight: 600 } }, "+ Create Plan"),
        ) : h("div", { className: "slide-up", style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}` } },
          h("input", { value: editName, onChange: e => setEditName(e.target.value), placeholder: "Session Name", style: { width: "100%", background: C.bg, border: `1px solid ${C.border}`, borderRadius: 8, padding: 12, color: C.text, fontSize: 15, marginBottom: 12, outline: "none" } }),
          h("div", { style: { fontSize: 12, color: C.textDim, marginBottom: 6 } }, "Exercises (one per line):"),
          h("textarea", { value: editExs, onChange: e => setEditExs(e.target.value), rows: 8, placeholder: "Bench Press\nLat Pulldown\nLeg Press", style: { width: "100%", background: C.bg, border: `1px solid ${C.border}`, borderRadius: 8, padding: 12, color: C.text, fontSize: 14, resize: "none", outline: "none" } }),
          h("div", { style: { display: "flex", gap: 8, marginTop: 12 } },
            h("button", { onClick: save, style: { flex: 1, background: C.green, color: C.bg, border: "none", borderRadius: 10, padding: 14, fontWeight: 700, cursor: "pointer" } }, "Save"),
            h("button", { onClick: () => setEditing(false), style: { flex: 1, background: C.bg, color: C.textDim, border: `1px solid ${C.border}`, borderRadius: 10, padding: 14, fontWeight: 600, cursor: "pointer" } }, "Cancel"),
          ),
        ),
      );
    }

    // ============================================================
    // HISTORY
    // ============================================================
    function History() {
      const { db, persist, notify } = useContext(AppCtx);
      const [expanded, setExpanded] = useState(null);
      const [editId, setEditId] = useState(null);
      const [editData, setEditData] = useState(null);
      const [confirmDelete, setConfirmDelete] = useState(null);

      const sorted = [...db.history].sort((a, b) => new Date(b.date) - new Date(a.date));

      function startCorrection(session) {
        setEditId(session.id);
        setEditData(deepClone(session));
      }

      function updateEditEx(ei, field, val) {
        setEditData(prev => {
          const next = deepClone(prev);
          next.exercises[ei][field] = val;
          if (field === "name") {
            next.exercises[ei].muscle = detectMuscle(val);
            next.exercises[ei].isCardio = isCardio(val);
          }
          return next;
        });
      }

      function updateEditSet(ei, si, field, val) {
        setEditData(prev => {
          const next = deepClone(prev);
          next.exercises[ei].sets[si][field] = val;
          return next;
        });
      }

      function addSetToEx(ei) {
        setEditData(prev => {
          const next = deepClone(prev);
          next.exercises[ei].sets.push({ weight: 0, reps: 0, completed: true });
          return next;
        });
      }

      function removeSetFromEx(ei, si) {
        setEditData(prev => {
          const next = deepClone(prev);
          if (next.exercises[ei].sets.length <= 1) return prev;
          next.exercises[ei].sets.splice(si, 1);
          return next;
        });
      }

      function removeExFromEdit(ei) {
        setEditData(prev => {
          const next = deepClone(prev);
          next.exercises.splice(ei, 1);
          return next;
        });
      }

      function addExToEdit() {
        setEditData(prev => {
          const next = deepClone(prev);
          next.exercises.push({ name: "New Exercise", muscle: "other", isCardio: false, sets: [{ weight: 0, reps: 0, completed: true }, { weight: 0, reps: 0, completed: true }, { weight: 0, reps: 0, completed: true }, { weight: 0, reps: 0, completed: true }] });
          return next;
        });
      }

      function saveCorrection() {
        if (!editData) return;
        persist(prev => ({ ...prev, history: prev.history.map(x => x.id === editData.id ? editData : x) }));
        setEditId(null); setEditData(null); notify("Workout updated", "success");
      }

      function cancelCorrection() { setEditId(null); setEditData(null); }

      function deleteWorkout(sid) {
        persist(prev => ({ ...prev, history: prev.history.filter(x => x.id !== sid) }));
        setExpanded(null); setEditId(null); setEditData(null); setConfirmDelete(null);
        notify("Workout deleted", "warn");
      }

      return h("div", { className: "fade-in", style: { padding: "20px 16px", maxWidth: 500, margin: "0 auto", paddingBottom: 90 } },
        h("h2", { style: { fontSize: 22, fontWeight: 800, marginBottom: 16 } }, "History"),
        sorted.length === 0 && h("div", { style: { textAlign: "center", color: C.textDim, padding: 40 } }, "No workouts yet. Get after it!"),
        sorted.map(x => {
          const isExp = expanded === x.id;
          const isEditing = editId === x.id && editData;
          const displayData = isEditing ? editData : x;
          const vol = (displayData.exercises || []).reduce((s, e) => s + (e.sets || []).reduce((ss, st) => ss + (st.weight || 0) * (st.reps || 0), 0), 0);
          const muscles = [...new Set((displayData.exercises || []).map(e => e.muscle))].filter(Boolean);
          return h("div", { key: x.id, style: { background: C.surface, borderRadius: 14, border: `1px solid ${isEditing ? C.amber + "60" : C.border}`, overflow: "hidden", marginBottom: 8 } },
            h("button", { onClick: () => { if (!isEditing) setExpanded(isExp ? null : x.id); }, style: { width: "100%", background: "none", border: "none", color: C.text, padding: "14px 16px", cursor: "pointer", textAlign: "left", display: "flex", justifyContent: "space-between", alignItems: "center" } },
              h("div", null,
                h("div", { style: { fontSize: 14, fontWeight: 600 } }, new Date(x.date).toLocaleDateString("en-AU", { weekday: "short", month: "short", day: "numeric" })),
                h("div", { style: { fontSize: 11, color: C.textDim, marginTop: 2 } }, `${muscles.join(", ")} â€¢ ${fmtDur(x.duration || 0)}`),
              ),
              h("div", { style: { textAlign: "right" } },
                h("div", { style: { fontSize: 16, fontWeight: 700, color: C.cyan, fontFamily: "'JetBrains Mono'" } }, vol > 1000 ? `${(vol / 1000).toFixed(1)}k` : vol),
                h("div", { style: { fontSize: 10, color: C.textDim } }, "kg vol"),
              ),
            ),
            // Expanded view (read-only)
            isExp && !isEditing && h("div", { className: "slide-up", style: { padding: "0 16px 16px", borderTop: `1px solid ${C.border}` } },
              (x.exercises || []).map((ex, ei) => h("div", { key: ei, style: { marginTop: 10 } },
                h("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center" } },
                  h("span", { style: { fontSize: 13, fontWeight: 600 } }, ex.name),
                  h("span", { style: { fontSize: 11, color: C.textDim, padding: "2px 8px", background: C.bg, borderRadius: 6 } }, ex.muscle),
                ),
                h("div", { style: { display: "flex", gap: 4, flexWrap: "wrap", marginTop: 4 } },
                  (ex.sets || []).map((s, si) => h("span", { key: si, style: { fontSize: 11, color: C.textDim, padding: "2px 8px", background: C.bg, borderRadius: 6 } }, `${s.weight}kg Ã— ${s.reps}`)),
                ),
              )),
              h("div", { style: { display: "flex", gap: 8, marginTop: 12 } },
                h("button", { onClick: () => startCorrection(x), style: { flex: 1, background: `${C.amber}15`, border: `1px solid ${C.amber}40`, borderRadius: 8, padding: 10, color: C.amber, fontSize: 12, fontWeight: 700, cursor: "pointer" } }, "âœï¸ Edit Workout"),
                h("button", { onClick: () => setConfirmDelete(x.id), style: { background: `${C.red}15`, border: `1px solid ${C.red}30`, borderRadius: 8, padding: "10px 14px", color: C.red, fontSize: 12, fontWeight: 700, cursor: "pointer" } }, "ðŸ—‘"),
              ),
              confirmDelete === x.id && h("div", { style: { marginTop: 8, padding: 12, background: `${C.red}10`, borderRadius: 8, border: `1px solid ${C.red}30`, textAlign: "center" } },
                h("div", { style: { fontSize: 13, color: C.red, fontWeight: 600, marginBottom: 8 } }, "Delete this workout?"),
                h("div", { style: { display: "flex", gap: 8 } },
                  h("button", { onClick: () => deleteWorkout(x.id), style: { flex: 1, background: C.red, color: "#fff", border: "none", borderRadius: 8, padding: 10, fontWeight: 700, cursor: "pointer", fontSize: 12 } }, "Yes, Delete"),
                  h("button", { onClick: () => setConfirmDelete(null), style: { flex: 1, background: C.bg, color: C.textDim, border: `1px solid ${C.border}`, borderRadius: 8, padding: 10, fontWeight: 600, cursor: "pointer", fontSize: 12 } }, "Cancel"),
                ),
              ),
            ),
            // Editing view (full correction mode)
            isEditing && h("div", { className: "slide-up", style: { padding: "0 16px 16px", borderTop: `1px solid ${C.amber}40` } },
              h("div", { style: { fontSize: 11, color: C.amber, textTransform: "uppercase", letterSpacing: 1, padding: "10px 0 6px", fontWeight: 700 } }, "âœï¸ Correction Mode"),
              // Duration editor
              h("div", { style: { background: C.bg, borderRadius: 10, padding: 12, marginBottom: 10, border: `1px solid ${C.border}` } },
                h("div", { style: { fontSize: 11, color: C.textDim, marginBottom: 6 } }, "Duration"),
                h("div", { style: { display: "flex", gap: 8, alignItems: "center" } },
                  h("input", { type: "number", inputMode: "numeric", value: Math.floor((editData.duration || 0) / 3600), onChange: e => { const hrs = parseInt(e.target.value) || 0; const mins = Math.floor(((editData.duration || 0) % 3600) / 60); setEditData(prev => ({ ...deepClone(prev), duration: hrs * 3600 + mins * 60 })); }, min: 0, style: { width: 60, background: C.surface, border: `1px solid ${C.border}`, borderRadius: 6, padding: "8px", color: C.cyan, fontSize: 14, fontFamily: "'JetBrains Mono'", textAlign: "center", outline: "none" } }),
                  h("span", { style: { fontSize: 12, color: C.textDim } }, "h"),
                  h("input", { type: "number", inputMode: "numeric", value: Math.floor(((editData.duration || 0) % 3600) / 60), onChange: e => { const hrs = Math.floor((editData.duration || 0) / 3600); const mins = parseInt(e.target.value) || 0; setEditData(prev => ({ ...deepClone(prev), duration: hrs * 3600 + mins * 60 })); }, min: 0, max: 59, style: { width: 60, background: C.surface, border: `1px solid ${C.border}`, borderRadius: 6, padding: "8px", color: C.cyan, fontSize: 14, fontFamily: "'JetBrains Mono'", textAlign: "center", outline: "none" } }),
                  h("span", { style: { fontSize: 12, color: C.textDim } }, "m"),
                  h("span", { style: { fontSize: 10, color: C.textDim, marginLeft: 8 } }, `(was ${fmtDur(x.duration || 0)})`),
                ),
              ),
              (editData.exercises || []).map((ex, ei) => h("div", { key: ei, style: { marginTop: 8, padding: 12, background: C.bg, borderRadius: 10, border: `1px solid ${C.border}` } },
                // Exercise name + muscle + remove
                h("div", { style: { display: "flex", gap: 6, marginBottom: 8, alignItems: "center" } },
                  h("input", { type: "text", value: ex.name, onChange: e => updateEditEx(ei, "name", e.target.value), style: { flex: 1, background: C.surface, border: `1px solid ${C.border}`, borderRadius: 6, padding: "8px 10px", color: C.text, fontSize: 13, outline: "none" } }),
                  h("select", { value: ex.muscle, onChange: e => updateEditEx(ei, "muscle", e.target.value), style: { background: C.surface, border: `1px solid ${C.border}`, borderRadius: 6, padding: "8px 6px", color: C.cyan, fontSize: 11, outline: "none", cursor: "pointer" } },
                    MUSCLE_GROUPS.map(m => h("option", { key: m, value: m }, m)),
                    h("option", { value: "other" }, "other"),
                  ),
                  h("button", { onClick: () => removeExFromEdit(ei), style: { background: "none", border: `1px solid ${C.red}30`, borderRadius: 6, padding: "6px 8px", color: C.red, fontSize: 11, cursor: "pointer", flexShrink: 0 } }, "âœ•"),
                ),
                // Set rows
                (ex.sets || []).map((s, si) => h("div", { key: si, style: { display: "flex", gap: 6, alignItems: "center", marginBottom: 4 } },
                  h("span", { style: { fontSize: 11, color: C.textDim, width: 20, textAlign: "center" } }, si + 1),
                  h("input", { type: "number", inputMode: "decimal", value: s.weight || "", onChange: e => updateEditSet(ei, si, "weight", parseFloat(e.target.value) || 0), placeholder: "kg", style: { flex: 1, background: C.surface, border: `1px solid ${C.cyanDim}`, borderRadius: 6, padding: "6px 8px", color: C.cyan, fontSize: 13, fontFamily: "'JetBrains Mono'", textAlign: "center", outline: "none" } }),
                  h("span", { style: { fontSize: 11, color: C.textDim } }, "Ã—"),
                  h("input", { type: "number", inputMode: "numeric", value: s.reps || "", onChange: e => updateEditSet(ei, si, "reps", parseInt(e.target.value) || 0), placeholder: "reps", style: { flex: 1, background: C.surface, border: `1px solid ${C.greenDim}`, borderRadius: 6, padding: "6px 8px", color: C.green, fontSize: 13, fontFamily: "'JetBrains Mono'", textAlign: "center", outline: "none" } }),
                  h("button", { onClick: () => removeSetFromEx(ei, si), style: { background: "none", border: "none", color: C.red, fontSize: 11, cursor: "pointer", padding: "4px 6px", opacity: ex.sets.length <= 1 ? 0.3 : 1 } }, "âœ•"),
                )),
                h("button", { onClick: () => addSetToEx(ei), style: { width: "100%", background: "none", border: `1px dashed ${C.border}`, borderRadius: 6, padding: 6, color: C.textDim, cursor: "pointer", fontSize: 11, marginTop: 4 } }, "+ Add Set"),
              )),
              h("button", { onClick: addExToEdit, style: { width: "100%", background: "none", border: `1px dashed ${C.cyan}40`, borderRadius: 8, padding: 10, color: C.cyan, cursor: "pointer", fontSize: 12, fontWeight: 600, marginTop: 8 } }, "+ Add Exercise"),
              h("div", { style: { display: "flex", gap: 8, marginTop: 12 } },
                h("button", { onClick: saveCorrection, style: { flex: 1, background: C.green, color: C.bg, border: "none", borderRadius: 8, padding: 12, fontWeight: 700, cursor: "pointer", fontSize: 13 } }, "Save Changes"),
                h("button", { onClick: cancelCorrection, style: { flex: 1, background: C.bg, color: C.textDim, border: `1px solid ${C.border}`, borderRadius: 8, padding: 12, fontWeight: 600, cursor: "pointer", fontSize: 13 } }, "Cancel"),
              ),
              h("button", { onClick: () => setConfirmDelete(x.id), style: { width: "100%", marginTop: 8, background: `${C.red}10`, border: `1px solid ${C.red}30`, borderRadius: 8, padding: 10, color: C.red, cursor: "pointer", fontSize: 12, fontWeight: 600 } }, "ðŸ—‘ Delete Workout"),
              confirmDelete === x.id && h("div", { style: { marginTop: 8, padding: 12, background: `${C.red}10`, borderRadius: 8, border: `1px solid ${C.red}30`, textAlign: "center" } },
                h("div", { style: { fontSize: 13, color: C.red, fontWeight: 600, marginBottom: 8 } }, "Delete this workout permanently?"),
                h("div", { style: { display: "flex", gap: 8 } },
                  h("button", { onClick: () => deleteWorkout(x.id), style: { flex: 1, background: C.red, color: "#fff", border: "none", borderRadius: 8, padding: 10, fontWeight: 700, cursor: "pointer", fontSize: 12 } }, "Yes, Delete"),
                  h("button", { onClick: () => setConfirmDelete(null), style: { flex: 1, background: C.bg, color: C.textDim, border: `1px solid ${C.border}`, borderRadius: 8, padding: 10, fontWeight: 600, cursor: "pointer", fontSize: 12 } }, "Cancel"),
                ),
              ),
            ),
          );
        }),
      );
    }

    // ============================================================
    // ANALYTICS
    // ============================================================
    function Analytics() {
      const { db, persist, notify } = useContext(AppCtx);
      const [editingPB, setEditingPB] = useState(null);
      const [pbWeight, setPbWeight] = useState(0);
      const [pbReps, setPbReps] = useState(0);

      // Weekly sessions data for chart â€” using Monday-AEST boundaries
      const weeklyData = useMemo(() => {
        const weeks = {};
        db.history.forEach(x => {
          const mon = getMonday(new Date(x.date));
          const k = mon.toISOString().split("T")[0];
          if (!weeks[k]) weeks[k] = { sessions: 0, sets: 0 };
          weeks[k].sessions++;
          (x.exercises || []).forEach(ex => { weeks[k].sets += (ex.sets || []).filter(s => s.completed !== false).length; });
        });
        return Object.entries(weeks).sort((a, b) => a[0].localeCompare(b[0])).slice(-8);
      }, [db.history]);

      const curSets = weeklyData.length > 0 ? weeklyData[weeklyData.length - 1][1].sets : 0;
      const lastSets = weeklyData.length > 1 ? weeklyData[weeklyData.length - 2][1].sets : 0;
      const change = lastSets > 0 ? ((curSets - lastSets) / lastSets * 100).toFixed(0) : 0;
      const curSessions = weeklyData.length > 0 ? weeklyData[weeklyData.length - 1][1].sessions : 0;

      const pbs = Object.entries(db.pbs || {}).sort((a, b) => b[1].maxWeight - a[1].maxWeight);

      function startEditPB(name, pb) { setEditingPB(name); setPbWeight(pb.maxWeight); setPbReps(pb.maxReps); }
      function savePB() {
        persist(prev => ({ ...prev, pbs: { ...prev.pbs, [editingPB]: { ...prev.pbs[editingPB], maxWeight: pbWeight, maxReps: pbReps } } }));
        setEditingPB(null); notify("PB updated", "success");
      }
      function deletePB(name) {
        persist(prev => { const pbs = { ...prev.pbs }; delete pbs[name]; return { ...prev, pbs }; });
        notify(`Deleted PB: ${name}`, "info");
      }

      return h("div", { className: "fade-in", style: { padding: "20px 16px", maxWidth: 500, margin: "0 auto", paddingBottom: 90 } },
        h("h2", { style: { fontSize: 22, fontWeight: 800, marginBottom: 16 } }, "Analytics"),
        // Weekly summary
        h("div", { style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}`, marginBottom: 12 } },
          h("div", { style: { fontSize: 11, color: C.textDim, textTransform: "uppercase", letterSpacing: 1, marginBottom: 12 } }, "This Week"),
          h("div", { style: { display: "flex", gap: 16, alignItems: "flex-end" } },
            h("div", { style: { flex: 1 } }, h("div", { style: { fontSize: 11, color: C.textDim, marginBottom: 4 } }, "Working Sets"), h("div", { style: { fontSize: 28, fontWeight: 700, color: C.cyan, fontFamily: "'JetBrains Mono'" } }, curSets)),
            h("div", { style: { flex: 1 } }, h("div", { style: { fontSize: 11, color: C.textDim, marginBottom: 4 } }, "Sessions"), h("div", { style: { fontSize: 28, fontWeight: 700, color: C.green, fontFamily: "'JetBrains Mono'" } }, curSessions)),
            lastSets > 0 && h("div", { style: { padding: "6px 14px", borderRadius: 20, fontSize: 14, fontWeight: 700, background: change >= 0 ? C.greenDim : C.redDim, color: change >= 0 ? C.green : C.red } }, `${change >= 0 ? "â†‘" : "â†“"} ${Math.abs(change)}%`),
          ),
        ),
        // Chart â€” weekly sets
        weeklyData.length > 0 && h("div", { style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}`, marginBottom: 12 } },
          h("div", { style: { fontSize: 11, color: C.textDim, textTransform: "uppercase", letterSpacing: 1, marginBottom: 16 } }, "Weekly Sets"),
          h("div", { style: { display: "flex", gap: 4, alignItems: "flex-end", height: 120 } },
            weeklyData.map(([w, d], i) => {
              const max = Math.max(...weeklyData.map(x => x[1].sets), 1);
              const ht = (d.sets / max) * 100;
              return h("div", { key: w, style: { flex: 1, display: "flex", flexDirection: "column", alignItems: "center", gap: 4 } },
                h("div", { style: { fontSize: 9, color: C.textDim } }, d.sets),
                h("div", { style: { width: "100%", height: `${ht}%`, minHeight: 4, background: i === weeklyData.length - 1 ? C.cyan : C.border, borderRadius: 4 } }),
                h("div", { style: { fontSize: 9, color: C.textDim } }, new Date(w).toLocaleDateString("en-AU", { day: "numeric", month: "short" })),
              );
            }),
          ),
        ),
        // PBs â€” editable
        h("div", { style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}` } },
          h("div", { style: { fontSize: 11, color: C.textDim, textTransform: "uppercase", letterSpacing: 1, marginBottom: 12 } }, "ðŸ† Personal Bests"),
          pbs.length === 0 && h("div", { style: { color: C.textDim, fontSize: 13 } }, "No PBs recorded yet"),
          pbs.map(([name, pb]) => editingPB === name
            ? h("div", { key: name, className: "slide-up", style: { padding: "12px", background: C.bg, borderRadius: 10, marginBottom: 4, border: `1px solid ${C.amber}40` } },
                h("div", { style: { fontSize: 13, fontWeight: 600, textTransform: "capitalize", marginBottom: 8, color: C.amber } }, name),
                h("div", { style: { display: "flex", gap: 8, marginBottom: 8 } },
                  h("div", { style: { flex: 1 } },
                    h("div", { style: { fontSize: 10, color: C.textDim, marginBottom: 4 } }, "Weight (kg)"),
                    h("input", { type: "number", inputMode: "decimal", value: pbWeight || "", onChange: e => setPbWeight(parseFloat(e.target.value) || 0), style: { width: "100%", background: C.surface, border: `1px solid ${C.border}`, borderRadius: 6, padding: "8px", color: C.cyan, fontSize: 14, fontFamily: "'JetBrains Mono'", textAlign: "center", outline: "none" } }),
                  ),
                  h("div", { style: { flex: 1 } },
                    h("div", { style: { fontSize: 10, color: C.textDim, marginBottom: 4 } }, "Max Reps"),
                    h("input", { type: "number", inputMode: "numeric", value: pbReps || "", onChange: e => setPbReps(parseInt(e.target.value) || 0), style: { width: "100%", background: C.surface, border: `1px solid ${C.border}`, borderRadius: 6, padding: "8px", color: C.green, fontSize: 14, fontFamily: "'JetBrains Mono'", textAlign: "center", outline: "none" } }),
                  ),
                ),
                h("div", { style: { display: "flex", gap: 8 } },
                  h("button", { onClick: savePB, style: { flex: 1, background: C.green, color: C.bg, border: "none", borderRadius: 8, padding: 10, fontWeight: 700, cursor: "pointer", fontSize: 12 } }, "Save"),
                  h("button", { onClick: () => deletePB(name), style: { flex: 1, background: C.red, color: "#fff", border: "none", borderRadius: 8, padding: 10, fontWeight: 700, cursor: "pointer", fontSize: 12 } }, "Delete"),
                  h("button", { onClick: () => setEditingPB(null), style: { flex: 1, background: C.bg, color: C.textDim, border: `1px solid ${C.border}`, borderRadius: 8, padding: 10, fontWeight: 600, cursor: "pointer", fontSize: 12 } }, "Cancel"),
                ),
              )
            : h("div", { key: name, style: { display: "flex", justifyContent: "space-between", alignItems: "center", padding: "10px 12px", background: C.bg, borderRadius: 8, marginBottom: 4, cursor: "pointer" }, onClick: () => startEditPB(name, pb) },
                h("span", { style: { fontSize: 13, fontWeight: 500, textTransform: "capitalize", flex: 1 } }, name),
                h("div", { style: { display: "flex", gap: 12, alignItems: "center" } },
                  h("span", { style: { fontSize: 13, color: C.cyan, fontFamily: "'JetBrains Mono'", fontWeight: 600 } }, `${pb.maxWeight}kg`),
                  h("span", { style: { fontSize: 13, color: C.green, fontFamily: "'JetBrains Mono'" } }, `${pb.maxReps}r`),
                  h("span", { style: { fontSize: 11, color: C.textDim, marginLeft: 4 } }, "âœï¸"),
                ),
              ),
          ),
        ),
      );
    }

    // ============================================================
    // SETTINGS
    // ============================================================
    function Settings() {
      const { db, persist, notify } = useContext(AppCtx);
      const t = db.settings?.timers || DEFAULT_TIMERS;
      function upd(k, v) { persist(prev => ({ ...prev, settings: { ...prev.settings, timers: { ...(prev.settings?.timers || DEFAULT_TIMERS), [k]: parseInt(v) || 0 } } })); }
      function clearAll() { if (confirm("This will erase ALL data. Are you sure?")) { persist(emptyDB()); notify("All data cleared", "warn"); } }
      function forceUpdate() {
        if ("serviceWorker" in navigator) {
          navigator.serviceWorker.getRegistrations().then(regs => {
            regs.forEach(r => r.unregister());
          });
          caches.keys().then(keys => Promise.all(keys.map(k => caches.delete(k)))).then(() => {
            notify("Cache cleared! Reloading...", "success");
            setTimeout(() => window.location.reload(true), 500);
          });
        } else {
          window.location.reload(true);
        }
      }
      const fields = [{ key: "prep", label: "Prep Timer", color: C.amber }, { key: "work", label: "Work Timer", color: C.cyan }, { key: "restSet", label: "Rest (Set)", color: C.green }, { key: "restEx", label: "Rest (Exercise)", color: C.purple }];

      return h("div", { className: "fade-in", style: { padding: "20px 16px", maxWidth: 500, margin: "0 auto", paddingBottom: 90 } },
        h("h2", { style: { fontSize: 22, fontWeight: 800, marginBottom: 16 } }, "Settings"),
        h("div", { style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}`, marginBottom: 12 } },
          h("div", { style: { fontSize: 13, fontWeight: 600, marginBottom: 14 } }, "Timer Defaults (seconds)"),
          fields.map(f => h("div", { key: f.key, style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 10 } },
            h("span", { style: { fontSize: 13, color: f.color } }, f.label),
            h("input", { type: "number", value: t[f.key], onChange: e => upd(f.key, e.target.value), style: { width: 80, background: C.bg, border: `1px solid ${C.border}`, borderRadius: 8, padding: "8px 12px", color: C.text, fontSize: 14, fontFamily: "'JetBrains Mono'", textAlign: "center", outline: "none" } }),
          )),
        ),
        // Force update button
        h("button", { onClick: forceUpdate, style: { width: "100%", background: C.surface, border: `1px solid ${C.cyan}30`, borderRadius: 12, padding: 14, color: C.cyan, cursor: "pointer", fontSize: 13, fontWeight: 600, marginBottom: 8 } }, "ðŸ”„ Force Update App"),
        h("div", { style: { fontSize: 10, color: C.textDim, textAlign: "center", marginBottom: 12 } }, "Clears cache and reloads. Your data is safe."),
        h("button", { onClick: clearAll, style: { width: "100%", background: C.surface, border: `1px solid ${C.red}30`, borderRadius: 12, padding: 14, color: C.red, cursor: "pointer", fontSize: 13, fontWeight: 600 } }, "âš ï¸ Clear All Data"),
        h("div", { style: { textAlign: "center", marginTop: 20, fontSize: 10, color: C.textDim } }, "RepVault v16"),
      );
    }

    // ============================================================
    // EXPORT
    // ============================================================
    function Export() {
      const { db, setScreen } = useContext(AppCtx);
      const [copied, setCopied] = useState(false);
      const data = useMemo(() => ({
        meta: { app: "RepVault", version: "2.0", exportedAt: new Date().toISOString(), format: "ai-ready" },
        summary: { totalSessions: db.history.length, totalExercises: db.history.reduce((s, x) => s + (x.exercises?.length || 0), 0), dateRange: db.history.length > 0 ? { from: db.history[0]?.date, to: db.history[db.history.length - 1]?.date } : null },
        personalBests: db.pbs, weeklyBlueprints: db.blueprints,
        history: db.history.map(x => ({ date: x.date, duration: x.duration, exercises: (x.exercises || []).map(ex => ({ name: ex.name, muscle: ex.muscle, sets: ex.sets, totalVolume: (ex.sets || []).reduce((s, st) => s + (st.weight || 0) * (st.reps || 0), 0) })), sessionVolume: (x.exercises || []).reduce((s, ex) => s + (ex.sets || []).reduce((ss, st) => ss + (st.weight || 0) * (st.reps || 0), 0), 0) })),
      }), [db]);

      function copy() { navigator.clipboard?.writeText(JSON.stringify(data, null, 2)); setCopied(true); setTimeout(() => setCopied(false), 2000); }

      return h("div", { className: "fade-in", style: { padding: "20px 16px", maxWidth: 500, margin: "0 auto", paddingBottom: 90 } },
        h("div", { style: { display: "flex", alignItems: "center", gap: 12, marginBottom: 16 } },
          h("button", { onClick: () => setScreen("home"), style: { background: "none", border: "none", color: C.textDim, fontSize: 20, cursor: "pointer" } }, "â†"),
          h("h2", { style: { fontSize: 22, fontWeight: 800 } }, "AI-Ready Export"),
        ),
        h("div", { style: { background: C.surface, borderRadius: 16, padding: 20, border: `1px solid ${C.border}`, marginBottom: 12 } },
          h("div", { style: { fontSize: 13, color: C.textDim, marginBottom: 12 } }, "Structured JSON for LLM consumption. Paste into Gemini, Claude, or ChatGPT for fatigue analysis and programming recommendations."),
          h("div", { style: { display: "flex", gap: 8, flexWrap: "wrap", marginBottom: 16 } },
            h("span", { style: { fontSize: 11, padding: "4px 10px", background: C.cyanDim, color: C.cyan, borderRadius: 20 } }, `${data.summary.totalSessions} sessions`),
            h("span", { style: { fontSize: 11, padding: "4px 10px", background: C.greenDim, color: C.green, borderRadius: 20 } }, `${data.summary.totalExercises} exercises`),
            h("span", { style: { fontSize: 11, padding: "4px 10px", background: C.amberDim, color: C.amber, borderRadius: 20 } }, `${Object.keys(db.pbs || {}).length} PBs`),
          ),
          h("button", { onClick: copy, style: { width: "100%", background: copied ? C.green : C.cyan, color: C.bg, border: "none", borderRadius: 12, padding: 16, fontSize: 15, fontWeight: 700, cursor: "pointer", transition: "background 0.3s" } }, copied ? "âœ“ Copied!" : "ðŸ“‹ Copy JSON to Clipboard"),
        ),
        h("div", { style: { background: C.surface, borderRadius: 16, padding: 16, border: `1px solid ${C.border}` } },
          h("div", { style: { fontSize: 11, color: C.textDim, marginBottom: 8, textTransform: "uppercase", letterSpacing: 1 } }, "Preview"),
          h("pre", { style: { fontSize: 10, color: C.textDim, overflow: "auto", maxHeight: 300, fontFamily: "'JetBrains Mono'", lineHeight: 1.4 } }, JSON.stringify(data, null, 2).slice(0, 2000)),
        ),
      );
    }

    // --- Mount ---
    ReactDOM.createRoot(document.getElementById("root")).render(React.createElement(App));

    // --- Service Worker: nuke old, register new ---
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", async () => {
        try {
          // First: unregister any existing SWs (kills the old cache-first one)
          const regs = await navigator.serviceWorker.getRegistrations();
          for (const r of regs) {
            await r.unregister();
          }
          // Clear old caches
          const keys = await caches.keys();
          for (const k of keys) {
            if (k.startsWith("repvault-")) await caches.delete(k);
          }
          // Now register fresh
          const reg = await navigator.serviceWorker.register("sw.js");
          reg.update();
        } catch(e) {
          console.log("SW setup:", e);
        }
      });
    }
  </script>
</body>
</html>
